// Built from precompiled binaries at https://github.com/bblanchon/pdfium-binaries/releases/tag/chromium/5772
// Github release api https://api.github.com/repos/bblanchon/pdfium-binaries/releases/102934879
// PDFium version v115.0.5772.0 chromium/5772 [master]
// Built on: Wed, 17 May 2023 13:34:04 GMT

// ReSharper disable all
#pragma warning disable CS8500 // This takes the address of, gets the size of, or declares a pointer to a managed type

// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace PdfLibCore.Generated
{
    public enum FPDF_TEXT_RENDERMODE
    {
        FPDF_TEXTRENDERMODE_UNKNOWN = -1,
        FPDF_TEXTRENDERMODE_FILL = 0,
        FPDF_TEXTRENDERMODE_STROKE = 1,
        FPDF_TEXTRENDERMODE_FILL_STROKE = 2,
        FPDF_TEXTRENDERMODE_INVISIBLE = 3,
        FPDF_TEXTRENDERMODE_FILL_CLIP = 4,
        FPDF_TEXTRENDERMODE_STROKE_CLIP = 5,
        FPDF_TEXTRENDERMODE_FILL_STROKE_CLIP = 6,
        FPDF_TEXTRENDERMODE_CLIP = 7,
        FPDF_TEXTRENDERMODE_LAST = 7
    }

    public enum FPDF_DUPLEXTYPE_
    {
        DuplexUndefined = 0,
        Simplex = 1,
        DuplexFlipShortEdge = 2,
        DuplexFlipLongEdge = 3
    }

    public enum FPDF_RENDERER_TYPE
    {
        FPDF_RENDERERTYPE_AGG = 0,
        FPDF_RENDERERTYPE_SKIA = 1
    }

    public unsafe partial class FPDF_Action : ISafePointer
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FPDF_Action __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FPDF_Action(native.ToPointer(), skipVTables);
        }

        internal static FPDF_Action __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_Action(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_Action(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FPDF_Action(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FPDF_Annotation : ISafePointer
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FPDF_Annotation __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FPDF_Annotation(native.ToPointer(), skipVTables);
        }

        internal static FPDF_Annotation __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_Annotation(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_Annotation(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FPDF_Annotation(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FPDF_Attachment : ISafePointer
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FPDF_Attachment __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FPDF_Attachment(native.ToPointer(), skipVTables);
        }

        internal static FPDF_Attachment __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_Attachment(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_Attachment(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FPDF_Attachment(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FPDF_Avail : ISafePointer
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FPDF_Avail __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FPDF_Avail(native.ToPointer(), skipVTables);
        }

        internal static FPDF_Avail __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_Avail(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_Avail(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FPDF_Avail(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FPDF_Bitmap : ISafePointer
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FPDF_Bitmap __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FPDF_Bitmap(native.ToPointer(), skipVTables);
        }

        internal static FPDF_Bitmap __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_Bitmap(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_Bitmap(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FPDF_Bitmap(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FPDF_Bookmark : ISafePointer
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FPDF_Bookmark __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FPDF_Bookmark(native.ToPointer(), skipVTables);
        }

        internal static FPDF_Bookmark __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_Bookmark(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_Bookmark(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FPDF_Bookmark(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FPDF_Clippath : ISafePointer
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FPDF_Clippath __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FPDF_Clippath(native.ToPointer(), skipVTables);
        }

        internal static FPDF_Clippath __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_Clippath(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_Clippath(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FPDF_Clippath(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FPDF_Dest : ISafePointer
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FPDF_Dest __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FPDF_Dest(native.ToPointer(), skipVTables);
        }

        internal static FPDF_Dest __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_Dest(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_Dest(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FPDF_Dest(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FPDF_Document : ISafePointer
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FPDF_Document __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FPDF_Document(native.ToPointer(), skipVTables);
        }

        internal static FPDF_Document __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_Document(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_Document(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FPDF_Document(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FPDF_Font : ISafePointer
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FPDF_Font __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FPDF_Font(native.ToPointer(), skipVTables);
        }

        internal static FPDF_Font __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_Font(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_Font(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FPDF_Font(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FPDF_Form_handle : ISafePointer
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FPDF_Form_handle __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FPDF_Form_handle(native.ToPointer(), skipVTables);
        }

        internal static FPDF_Form_handle __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_Form_handle(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_Form_handle(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FPDF_Form_handle(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FPDF_Glyphpath : ISafePointer
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FPDF_Glyphpath __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FPDF_Glyphpath(native.ToPointer(), skipVTables);
        }

        internal static FPDF_Glyphpath __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_Glyphpath(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_Glyphpath(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FPDF_Glyphpath(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FpdfJavascriptActionT : ISafePointer
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FpdfJavascriptActionT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FpdfJavascriptActionT(native.ToPointer(), skipVTables);
        }

        internal static FpdfJavascriptActionT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FpdfJavascriptActionT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfJavascriptActionT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FpdfJavascriptActionT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FPDF_Link : ISafePointer
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FPDF_Link __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FPDF_Link(native.ToPointer(), skipVTables);
        }

        internal static FPDF_Link __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_Link(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_Link(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FPDF_Link(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FPDF_Page : ISafePointer
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FPDF_Page __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FPDF_Page(native.ToPointer(), skipVTables);
        }

        internal static FPDF_Page __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_Page(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_Page(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FPDF_Page(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FPDF_Pagelink : ISafePointer
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FPDF_Pagelink __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FPDF_Pagelink(native.ToPointer(), skipVTables);
        }

        internal static FPDF_Pagelink __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_Pagelink(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_Pagelink(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FPDF_Pagelink(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FPDF_Pageobject : ISafePointer
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FPDF_Pageobject __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FPDF_Pageobject(native.ToPointer(), skipVTables);
        }

        internal static FPDF_Pageobject __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_Pageobject(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_Pageobject(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FPDF_Pageobject(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FPDF_Pageobjectmark : ISafePointer
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FPDF_Pageobjectmark __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FPDF_Pageobjectmark(native.ToPointer(), skipVTables);
        }

        internal static FPDF_Pageobjectmark __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_Pageobjectmark(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_Pageobjectmark(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FPDF_Pageobjectmark(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FPDF_Pagerange : ISafePointer
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FPDF_Pagerange __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FPDF_Pagerange(native.ToPointer(), skipVTables);
        }

        internal static FPDF_Pagerange __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_Pagerange(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_Pagerange(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FPDF_Pagerange(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FpdfPathsegmentT : ISafePointer
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FpdfPathsegmentT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FpdfPathsegmentT(native.ToPointer(), skipVTables);
        }

        internal static FpdfPathsegmentT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FpdfPathsegmentT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FpdfPathsegmentT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FpdfPathsegmentT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FPDF_Schhandle : ISafePointer
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FPDF_Schhandle __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FPDF_Schhandle(native.ToPointer(), skipVTables);
        }

        internal static FPDF_Schhandle __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_Schhandle(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_Schhandle(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FPDF_Schhandle(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FPDF_Signature : ISafePointer
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FPDF_Signature __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FPDF_Signature(native.ToPointer(), skipVTables);
        }

        internal static FPDF_Signature __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_Signature(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_Signature(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FPDF_Signature(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FPDF_Structelement : ISafePointer
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FPDF_Structelement __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FPDF_Structelement(native.ToPointer(), skipVTables);
        }

        internal static FPDF_Structelement __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_Structelement(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_Structelement(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FPDF_Structelement(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FPDF_Structelement_attr : ISafePointer
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FPDF_Structelement_attr __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FPDF_Structelement_attr(native.ToPointer(), skipVTables);
        }

        internal static FPDF_Structelement_attr __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_Structelement_attr(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_Structelement_attr(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FPDF_Structelement_attr(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FPDF_Structtree : ISafePointer
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FPDF_Structtree __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FPDF_Structtree(native.ToPointer(), skipVTables);
        }

        internal static FPDF_Structtree __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_Structtree(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_Structtree(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FPDF_Structtree(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FPDF_Textpage : ISafePointer
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FPDF_Textpage __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FPDF_Textpage(native.ToPointer(), skipVTables);
        }

        internal static FPDF_Textpage __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_Textpage(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_Textpage(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FPDF_Textpage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FPDF_Widget : ISafePointer
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FPDF_Widget __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FPDF_Widget(native.ToPointer(), skipVTables);
        }

        internal static FPDF_Widget __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_Widget(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_Widget(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FPDF_Widget(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FPDF_Xobject : ISafePointer
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FPDF_Xobject __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FPDF_Xobject(native.ToPointer(), skipVTables);
        }

        internal static FPDF_Xobject __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_Xobject(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_Xobject(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FPDF_Xobject(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class FPDF_BSTR_ : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr str;
            internal int len;

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "??0FPDF_BSTR_@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FPDF_BSTR_ __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FPDF_BSTR_(native.ToPointer(), skipVTables);
        }

        internal static FPDF_BSTR_ __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_BSTR_(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_BSTR_(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FPDF_BSTR_(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FPDF_BSTR_()
        {
            if (GetType().FullName != "PdfLibCore.Generated.FPDF_BSTR_")
                throw new Exception("PdfLibCore.Generated.FPDF_BSTR_: Can't inherit from classes with disabled NativeToManaged map");
            __Instance = Marshal.AllocHGlobal(sizeof(global::PdfLibCore.Generated.FPDF_BSTR_.__Internal));
            __ownsNativeInstance = true;
        }

        public FPDF_BSTR_(global::PdfLibCore.Generated.FPDF_BSTR_ _0)
        {
            if (GetType().FullName != "PdfLibCore.Generated.FPDF_BSTR_")
                throw new Exception("PdfLibCore.Generated.FPDF_BSTR_: Can't inherit from classes with disabled NativeToManaged map");
            __Instance = Marshal.AllocHGlobal(sizeof(global::PdfLibCore.Generated.FPDF_BSTR_.__Internal));
            __ownsNativeInstance = true;
            *((global::PdfLibCore.Generated.FPDF_BSTR_.__Internal*) __Instance) = *((global::PdfLibCore.Generated.FPDF_BSTR_.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte* Str
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->str;
            }

            set
            {
                ((__Internal*)__Instance)->str = (__IntPtr) value;
            }
        }

        public int Len
        {
            get
            {
                return ((__Internal*)__Instance)->len;
            }

            set
            {
                ((__Internal*)__Instance)->len = value;
            }
        }
    }

    public unsafe partial class FS_MATRIX_ : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal float a;
            internal float b;
            internal float c;
            internal float d;
            internal float e;
            internal float f;

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "??0_FS_MATRIX_@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FS_MATRIX_ __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FS_MATRIX_(native.ToPointer(), skipVTables);
        }

        internal static FS_MATRIX_ __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FS_MATRIX_(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FS_MATRIX_(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FS_MATRIX_(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FS_MATRIX_()
        {
            if (GetType().FullName != "PdfLibCore.Generated.FS_MATRIX_")
                throw new Exception("PdfLibCore.Generated.FS_MATRIX_: Can't inherit from classes with disabled NativeToManaged map");
            __Instance = Marshal.AllocHGlobal(sizeof(global::PdfLibCore.Generated.FS_MATRIX_.__Internal));
            __ownsNativeInstance = true;
        }

        public FS_MATRIX_(global::PdfLibCore.Generated.FS_MATRIX_ _0)
        {
            if (GetType().FullName != "PdfLibCore.Generated.FS_MATRIX_")
                throw new Exception("PdfLibCore.Generated.FS_MATRIX_: Can't inherit from classes with disabled NativeToManaged map");
            __Instance = Marshal.AllocHGlobal(sizeof(global::PdfLibCore.Generated.FS_MATRIX_.__Internal));
            __ownsNativeInstance = true;
            *((global::PdfLibCore.Generated.FS_MATRIX_.__Internal*) __Instance) = *((global::PdfLibCore.Generated.FS_MATRIX_.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float A
        {
            get
            {
                return ((__Internal*)__Instance)->a;
            }

            set
            {
                ((__Internal*)__Instance)->a = value;
            }
        }

        public float B
        {
            get
            {
                return ((__Internal*)__Instance)->b;
            }

            set
            {
                ((__Internal*)__Instance)->b = value;
            }
        }

        public float C
        {
            get
            {
                return ((__Internal*)__Instance)->c;
            }

            set
            {
                ((__Internal*)__Instance)->c = value;
            }
        }

        public float D
        {
            get
            {
                return ((__Internal*)__Instance)->d;
            }

            set
            {
                ((__Internal*)__Instance)->d = value;
            }
        }

        public float E
        {
            get
            {
                return ((__Internal*)__Instance)->e;
            }

            set
            {
                ((__Internal*)__Instance)->e = value;
            }
        }

        public float F
        {
            get
            {
                return ((__Internal*)__Instance)->f;
            }

            set
            {
                ((__Internal*)__Instance)->f = value;
            }
        }
    }

    public unsafe partial class FS_RECTF_ : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal float left;
            internal float top;
            internal float right;
            internal float bottom;

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "??0_FS_RECTF_@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FS_RECTF_ __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FS_RECTF_(native.ToPointer(), skipVTables);
        }

        internal static FS_RECTF_ __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FS_RECTF_(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FS_RECTF_(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FS_RECTF_(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FS_RECTF_()
        {
            if (GetType().FullName != "PdfLibCore.Generated.FS_RECTF_")
                throw new Exception("PdfLibCore.Generated.FS_RECTF_: Can't inherit from classes with disabled NativeToManaged map");
            __Instance = Marshal.AllocHGlobal(sizeof(global::PdfLibCore.Generated.FS_RECTF_.__Internal));
            __ownsNativeInstance = true;
        }

        public FS_RECTF_(global::PdfLibCore.Generated.FS_RECTF_ _0)
        {
            if (GetType().FullName != "PdfLibCore.Generated.FS_RECTF_")
                throw new Exception("PdfLibCore.Generated.FS_RECTF_: Can't inherit from classes with disabled NativeToManaged map");
            __Instance = Marshal.AllocHGlobal(sizeof(global::PdfLibCore.Generated.FS_RECTF_.__Internal));
            __ownsNativeInstance = true;
            *((global::PdfLibCore.Generated.FS_RECTF_.__Internal*) __Instance) = *((global::PdfLibCore.Generated.FS_RECTF_.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float Left
        {
            get
            {
                return ((__Internal*)__Instance)->left;
            }

            set
            {
                ((__Internal*)__Instance)->left = value;
            }
        }

        public float Top
        {
            get
            {
                return ((__Internal*)__Instance)->top;
            }

            set
            {
                ((__Internal*)__Instance)->top = value;
            }
        }

        public float Right
        {
            get
            {
                return ((__Internal*)__Instance)->right;
            }

            set
            {
                ((__Internal*)__Instance)->right = value;
            }
        }

        public float Bottom
        {
            get
            {
                return ((__Internal*)__Instance)->bottom;
            }

            set
            {
                ((__Internal*)__Instance)->bottom = value;
            }
        }
    }

    public unsafe partial class FS_SIZEF_ : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal float width;
            internal float height;

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "??0FS_SIZEF_@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FS_SIZEF_ __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FS_SIZEF_(native.ToPointer(), skipVTables);
        }

        internal static FS_SIZEF_ __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FS_SIZEF_(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FS_SIZEF_(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FS_SIZEF_(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FS_SIZEF_()
        {
            if (GetType().FullName != "PdfLibCore.Generated.FS_SIZEF_")
                throw new Exception("PdfLibCore.Generated.FS_SIZEF_: Can't inherit from classes with disabled NativeToManaged map");
            __Instance = Marshal.AllocHGlobal(sizeof(global::PdfLibCore.Generated.FS_SIZEF_.__Internal));
            __ownsNativeInstance = true;
        }

        public FS_SIZEF_(global::PdfLibCore.Generated.FS_SIZEF_ _0)
        {
            if (GetType().FullName != "PdfLibCore.Generated.FS_SIZEF_")
                throw new Exception("PdfLibCore.Generated.FS_SIZEF_: Can't inherit from classes with disabled NativeToManaged map");
            __Instance = Marshal.AllocHGlobal(sizeof(global::PdfLibCore.Generated.FS_SIZEF_.__Internal));
            __ownsNativeInstance = true;
            *((global::PdfLibCore.Generated.FS_SIZEF_.__Internal*) __Instance) = *((global::PdfLibCore.Generated.FS_SIZEF_.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float Width
        {
            get
            {
                return ((__Internal*)__Instance)->width;
            }

            set
            {
                ((__Internal*)__Instance)->width = value;
            }
        }

        public float Height
        {
            get
            {
                return ((__Internal*)__Instance)->height;
            }

            set
            {
                ((__Internal*)__Instance)->height = value;
            }
        }
    }

    public unsafe partial class FS_POINTF_ : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal float x;
            internal float y;

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "??0FS_POINTF_@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FS_POINTF_ __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FS_POINTF_(native.ToPointer(), skipVTables);
        }

        internal static FS_POINTF_ __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FS_POINTF_(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FS_POINTF_(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FS_POINTF_(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FS_POINTF_()
        {
            if (GetType().FullName != "PdfLibCore.Generated.FS_POINTF_")
                throw new Exception("PdfLibCore.Generated.FS_POINTF_: Can't inherit from classes with disabled NativeToManaged map");
            __Instance = Marshal.AllocHGlobal(sizeof(global::PdfLibCore.Generated.FS_POINTF_.__Internal));
            __ownsNativeInstance = true;
        }

        public FS_POINTF_(global::PdfLibCore.Generated.FS_POINTF_ _0)
        {
            if (GetType().FullName != "PdfLibCore.Generated.FS_POINTF_")
                throw new Exception("PdfLibCore.Generated.FS_POINTF_: Can't inherit from classes with disabled NativeToManaged map");
            __Instance = Marshal.AllocHGlobal(sizeof(global::PdfLibCore.Generated.FS_POINTF_.__Internal));
            __ownsNativeInstance = true;
            *((global::PdfLibCore.Generated.FS_POINTF_.__Internal*) __Instance) = *((global::PdfLibCore.Generated.FS_POINTF_.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        public float Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }
    }

    public unsafe partial class FS_QUADPOINTSF : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal float x1;
            internal float y1;
            internal float x2;
            internal float y2;
            internal float x3;
            internal float y3;
            internal float x4;
            internal float y4;

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "??0_FS_QUADPOINTSF@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FS_QUADPOINTSF __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FS_QUADPOINTSF(native.ToPointer(), skipVTables);
        }

        internal static FS_QUADPOINTSF __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FS_QUADPOINTSF(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FS_QUADPOINTSF(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FS_QUADPOINTSF(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FS_QUADPOINTSF()
        {
            if (GetType().FullName != "PdfLibCore.Generated.FS_QUADPOINTSF")
                throw new Exception("PdfLibCore.Generated.FS_QUADPOINTSF: Can't inherit from classes with disabled NativeToManaged map");
            __Instance = Marshal.AllocHGlobal(sizeof(global::PdfLibCore.Generated.FS_QUADPOINTSF.__Internal));
            __ownsNativeInstance = true;
        }

        public FS_QUADPOINTSF(global::PdfLibCore.Generated.FS_QUADPOINTSF _0)
        {
            if (GetType().FullName != "PdfLibCore.Generated.FS_QUADPOINTSF")
                throw new Exception("PdfLibCore.Generated.FS_QUADPOINTSF: Can't inherit from classes with disabled NativeToManaged map");
            __Instance = Marshal.AllocHGlobal(sizeof(global::PdfLibCore.Generated.FS_QUADPOINTSF.__Internal));
            __ownsNativeInstance = true;
            *((global::PdfLibCore.Generated.FS_QUADPOINTSF.__Internal*) __Instance) = *((global::PdfLibCore.Generated.FS_QUADPOINTSF.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float X1
        {
            get
            {
                return ((__Internal*)__Instance)->x1;
            }

            set
            {
                ((__Internal*)__Instance)->x1 = value;
            }
        }

        public float Y1
        {
            get
            {
                return ((__Internal*)__Instance)->y1;
            }

            set
            {
                ((__Internal*)__Instance)->y1 = value;
            }
        }

        public float X2
        {
            get
            {
                return ((__Internal*)__Instance)->x2;
            }

            set
            {
                ((__Internal*)__Instance)->x2 = value;
            }
        }

        public float Y2
        {
            get
            {
                return ((__Internal*)__Instance)->y2;
            }

            set
            {
                ((__Internal*)__Instance)->y2 = value;
            }
        }

        public float X3
        {
            get
            {
                return ((__Internal*)__Instance)->x3;
            }

            set
            {
                ((__Internal*)__Instance)->x3 = value;
            }
        }

        public float Y3
        {
            get
            {
                return ((__Internal*)__Instance)->y3;
            }

            set
            {
                ((__Internal*)__Instance)->y3 = value;
            }
        }

        public float X4
        {
            get
            {
                return ((__Internal*)__Instance)->x4;
            }

            set
            {
                ((__Internal*)__Instance)->x4 = value;
            }
        }

        public float Y4
        {
            get
            {
                return ((__Internal*)__Instance)->y4;
            }

            set
            {
                ((__Internal*)__Instance)->y4 = value;
            }
        }
    }

    public unsafe partial class FPDF_LIBRARY_CONFIG_ : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48)]
        public partial struct __Internal
        {
            internal int version;
            internal __IntPtr m_pUserFontPaths;
            internal __IntPtr m_pIsolate;
            internal uint m_v8EmbedderSlot;
            internal __IntPtr m_pPlatform;
            internal global::PdfLibCore.Generated.FPDF_RENDERER_TYPE m_RendererType;

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "??0FPDF_LIBRARY_CONFIG_@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FPDF_LIBRARY_CONFIG_ __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FPDF_LIBRARY_CONFIG_(native.ToPointer(), skipVTables);
        }

        internal static FPDF_LIBRARY_CONFIG_ __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_LIBRARY_CONFIG_(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_LIBRARY_CONFIG_(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FPDF_LIBRARY_CONFIG_(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FPDF_LIBRARY_CONFIG_()
        {
            if (GetType().FullName != "PdfLibCore.Generated.FPDF_LIBRARY_CONFIG_")
                throw new Exception("PdfLibCore.Generated.FPDF_LIBRARY_CONFIG_: Can't inherit from classes with disabled NativeToManaged map");
            __Instance = Marshal.AllocHGlobal(sizeof(global::PdfLibCore.Generated.FPDF_LIBRARY_CONFIG_.__Internal));
            __ownsNativeInstance = true;
        }

        public FPDF_LIBRARY_CONFIG_(global::PdfLibCore.Generated.FPDF_LIBRARY_CONFIG_ _0)
        {
            if (GetType().FullName != "PdfLibCore.Generated.FPDF_LIBRARY_CONFIG_")
                throw new Exception("PdfLibCore.Generated.FPDF_LIBRARY_CONFIG_: Can't inherit from classes with disabled NativeToManaged map");
            __Instance = Marshal.AllocHGlobal(sizeof(global::PdfLibCore.Generated.FPDF_LIBRARY_CONFIG_.__Internal));
            __ownsNativeInstance = true;
            *((global::PdfLibCore.Generated.FPDF_LIBRARY_CONFIG_.__Internal*) __Instance) = *((global::PdfLibCore.Generated.FPDF_LIBRARY_CONFIG_.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Version
        {
            get
            {
                return ((__Internal*)__Instance)->version;
            }

            set
            {
                ((__Internal*)__Instance)->version = value;
            }
        }

        public __IntPtr MPIsolate
        {
            get
            {
                return ((__Internal*)__Instance)->m_pIsolate;
            }

            set
            {
                ((__Internal*)__Instance)->m_pIsolate = (__IntPtr) value;
            }
        }

        public uint MV8EmbedderSlot
        {
            get
            {
                return ((__Internal*)__Instance)->m_v8EmbedderSlot;
            }

            set
            {
                ((__Internal*)__Instance)->m_v8EmbedderSlot = value;
            }
        }

        public __IntPtr MPPlatform
        {
            get
            {
                return ((__Internal*)__Instance)->m_pPlatform;
            }

            set
            {
                ((__Internal*)__Instance)->m_pPlatform = (__IntPtr) value;
            }
        }

        public global::PdfLibCore.Generated.FPDF_RENDERER_TYPE MRendererType
        {
            get
            {
                return ((__Internal*)__Instance)->m_RendererType;
            }

            set
            {
                ((__Internal*)__Instance)->m_RendererType = value;
            }
        }
    }

    public unsafe partial class FPDF_FILEACCESS : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal uint m_FileLen;
            internal __IntPtr m_GetBlock;
            internal __IntPtr m_Param;

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "??0FPDF_FILEACCESS@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FPDF_FILEACCESS __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FPDF_FILEACCESS(native.ToPointer(), skipVTables);
        }

        internal static FPDF_FILEACCESS __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_FILEACCESS(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_FILEACCESS(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FPDF_FILEACCESS(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FPDF_FILEACCESS()
        {
            if (GetType().FullName != "PdfLibCore.Generated.FPDF_FILEACCESS")
                throw new Exception("PdfLibCore.Generated.FPDF_FILEACCESS: Can't inherit from classes with disabled NativeToManaged map");
            __Instance = Marshal.AllocHGlobal(sizeof(global::PdfLibCore.Generated.FPDF_FILEACCESS.__Internal));
            __ownsNativeInstance = true;
        }

        public FPDF_FILEACCESS(global::PdfLibCore.Generated.FPDF_FILEACCESS __0)
        {
            if (GetType().FullName != "PdfLibCore.Generated.FPDF_FILEACCESS")
                throw new Exception("PdfLibCore.Generated.FPDF_FILEACCESS: Can't inherit from classes with disabled NativeToManaged map");
            __Instance = Marshal.AllocHGlobal(sizeof(global::PdfLibCore.Generated.FPDF_FILEACCESS.__Internal));
            __ownsNativeInstance = true;
            *((global::PdfLibCore.Generated.FPDF_FILEACCESS.__Internal*) __Instance) = *((global::PdfLibCore.Generated.FPDF_FILEACCESS.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint MFileLen
        {
            get
            {
                return ((__Internal*)__Instance)->m_FileLen;
            }

            set
            {
                ((__Internal*)__Instance)->m_FileLen = value;
            }
        }

        public global::PdfLibCore.Generated.Delegates.Func_int___IntPtr_uint_bytePtr_uint MGetBlock
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->m_GetBlock;
                return __ptr0 == IntPtr.Zero? null : (global::PdfLibCore.Generated.Delegates.Func_int___IntPtr_uint_bytePtr_uint) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PdfLibCore.Generated.Delegates.Func_int___IntPtr_uint_bytePtr_uint));
            }

            set
            {
                ((__Internal*)__Instance)->m_GetBlock = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr MParam
        {
            get
            {
                return ((__Internal*)__Instance)->m_Param;
            }

            set
            {
                ((__Internal*)__Instance)->m_Param = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class FPDF_FILEHANDLER_ : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56)]
        public partial struct __Internal
        {
            internal __IntPtr clientData;
            internal __IntPtr Release;
            internal __IntPtr GetSize;
            internal __IntPtr ReadBlock;
            internal __IntPtr WriteBlock;
            internal __IntPtr Flush;
            internal __IntPtr Truncate;

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "??0FPDF_FILEHANDLER_@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FPDF_FILEHANDLER_ __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FPDF_FILEHANDLER_(native.ToPointer(), skipVTables);
        }

        internal static FPDF_FILEHANDLER_ __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_FILEHANDLER_(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_FILEHANDLER_(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FPDF_FILEHANDLER_(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FPDF_FILEHANDLER_()
        {
            if (GetType().FullName != "PdfLibCore.Generated.FPDF_FILEHANDLER_")
                throw new Exception("PdfLibCore.Generated.FPDF_FILEHANDLER_: Can't inherit from classes with disabled NativeToManaged map");
            __Instance = Marshal.AllocHGlobal(sizeof(global::PdfLibCore.Generated.FPDF_FILEHANDLER_.__Internal));
            __ownsNativeInstance = true;
        }

        public FPDF_FILEHANDLER_(global::PdfLibCore.Generated.FPDF_FILEHANDLER_ _0)
        {
            if (GetType().FullName != "PdfLibCore.Generated.FPDF_FILEHANDLER_")
                throw new Exception("PdfLibCore.Generated.FPDF_FILEHANDLER_: Can't inherit from classes with disabled NativeToManaged map");
            __Instance = Marshal.AllocHGlobal(sizeof(global::PdfLibCore.Generated.FPDF_FILEHANDLER_.__Internal));
            __ownsNativeInstance = true;
            *((global::PdfLibCore.Generated.FPDF_FILEHANDLER_.__Internal*) __Instance) = *((global::PdfLibCore.Generated.FPDF_FILEHANDLER_.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr ClientData
        {
            get
            {
                return ((__Internal*)__Instance)->clientData;
            }

            set
            {
                ((__Internal*)__Instance)->clientData = (__IntPtr) value;
            }
        }

        public global::PdfLibCore.Generated.Delegates.Action___IntPtr Release
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Release;
                return __ptr0 == IntPtr.Zero? null : (global::PdfLibCore.Generated.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PdfLibCore.Generated.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Release = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PdfLibCore.Generated.Delegates.Func_long___IntPtr GetSize
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->GetSize;
                return __ptr0 == IntPtr.Zero? null : (global::PdfLibCore.Generated.Delegates.Func_long___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PdfLibCore.Generated.Delegates.Func_long___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->GetSize = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PdfLibCore.Generated.Delegates.Func_int___IntPtr_long___IntPtr_long ReadBlock
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->ReadBlock;
                return __ptr0 == IntPtr.Zero? null : (global::PdfLibCore.Generated.Delegates.Func_int___IntPtr_long___IntPtr_long) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PdfLibCore.Generated.Delegates.Func_int___IntPtr_long___IntPtr_long));
            }

            set
            {
                ((__Internal*)__Instance)->ReadBlock = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PdfLibCore.Generated.Delegates.Func_int___IntPtr_long___IntPtr_long WriteBlock
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->WriteBlock;
                return __ptr0 == IntPtr.Zero? null : (global::PdfLibCore.Generated.Delegates.Func_int___IntPtr_long___IntPtr_long) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PdfLibCore.Generated.Delegates.Func_int___IntPtr_long___IntPtr_long));
            }

            set
            {
                ((__Internal*)__Instance)->WriteBlock = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PdfLibCore.Generated.Delegates.Func_int___IntPtr Flush
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Flush;
                return __ptr0 == IntPtr.Zero? null : (global::PdfLibCore.Generated.Delegates.Func_int___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PdfLibCore.Generated.Delegates.Func_int___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Flush = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::PdfLibCore.Generated.Delegates.Func_int___IntPtr_long Truncate
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Truncate;
                return __ptr0 == IntPtr.Zero? null : (global::PdfLibCore.Generated.Delegates.Func_int___IntPtr_long) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PdfLibCore.Generated.Delegates.Func_int___IntPtr_long));
            }

            set
            {
                ((__Internal*)__Instance)->Truncate = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class FPDF_COLORSCHEME_ : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal long path_fill_color;
            internal long path_stroke_color;
            internal long text_fill_color;
            internal long text_stroke_color;

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "??0FPDF_COLORSCHEME_@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FPDF_COLORSCHEME_ __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FPDF_COLORSCHEME_(native.ToPointer(), skipVTables);
        }

        internal static FPDF_COLORSCHEME_ __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_COLORSCHEME_(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_COLORSCHEME_(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FPDF_COLORSCHEME_(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FPDF_COLORSCHEME_()
        {
            if (GetType().FullName != "PdfLibCore.Generated.FPDF_COLORSCHEME_")
                throw new Exception("PdfLibCore.Generated.FPDF_COLORSCHEME_: Can't inherit from classes with disabled NativeToManaged map");
            __Instance = Marshal.AllocHGlobal(sizeof(global::PdfLibCore.Generated.FPDF_COLORSCHEME_.__Internal));
            __ownsNativeInstance = true;
        }

        public FPDF_COLORSCHEME_(global::PdfLibCore.Generated.FPDF_COLORSCHEME_ _0)
        {
            if (GetType().FullName != "PdfLibCore.Generated.FPDF_COLORSCHEME_")
                throw new Exception("PdfLibCore.Generated.FPDF_COLORSCHEME_: Can't inherit from classes with disabled NativeToManaged map");
            __Instance = Marshal.AllocHGlobal(sizeof(global::PdfLibCore.Generated.FPDF_COLORSCHEME_.__Internal));
            __ownsNativeInstance = true;
            *((global::PdfLibCore.Generated.FPDF_COLORSCHEME_.__Internal*) __Instance) = *((global::PdfLibCore.Generated.FPDF_COLORSCHEME_.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public long PathFillColor
        {
            get
            {
                return ((__Internal*)__Instance)->path_fill_color;
            }

            set
            {
                ((__Internal*)__Instance)->path_fill_color = value;
            }
        }

        public long PathStrokeColor
        {
            get
            {
                return ((__Internal*)__Instance)->path_stroke_color;
            }

            set
            {
                ((__Internal*)__Instance)->path_stroke_color = value;
            }
        }

        public long TextFillColor
        {
            get
            {
                return ((__Internal*)__Instance)->text_fill_color;
            }

            set
            {
                ((__Internal*)__Instance)->text_fill_color = value;
            }
        }

        public long TextStrokeColor
        {
            get
            {
                return ((__Internal*)__Instance)->text_stroke_color;
            }

            set
            {
                ((__Internal*)__Instance)->text_stroke_color = value;
            }
        }
    }

    public static unsafe partial class Pdfium
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_InitLibrary", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDF_InitLibrary();

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_InitLibraryWithConfig", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDF_InitLibraryWithConfig(__IntPtr config);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_DestroyLibrary", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDF_DestroyLibrary();

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_SetSandBoxPolicy", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDF_SetSandBoxPolicy(long policy, global::PdfLibCore.Types.FPDF_BOOL enable);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_LoadDocument", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDF_LoadDocument(string file_path, string password);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_LoadMemDocument", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDF_LoadMemDocument(__IntPtr data_buf, int size, string password);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_LoadMemDocument64", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDF_LoadMemDocument64(__IntPtr data_buf, ulong size, string password);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_LoadCustomDocument", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDF_LoadCustomDocument(__IntPtr pFileAccess, string password);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_GetFileVersion", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::PdfLibCore.Types.FPDF_BOOL FPDF_GetFileVersion(__IntPtr doc, int* fileVersion);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_GetLastError", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::PdfLibCore.Types.FPDF_ERR FPDF_GetLastError();

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_DocumentHasValidCrossReferenceTable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::PdfLibCore.Types.FPDF_BOOL FPDF_DocumentHasValidCrossReferenceTable(__IntPtr document);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_GetTrailerEnds", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDF_GetTrailerEnds(__IntPtr document, uint* buffer, uint length);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_GetDocPermissions", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDF_GetDocPermissions(__IntPtr document);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_GetSecurityHandlerRevision", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_GetSecurityHandlerRevision(__IntPtr document);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_GetPageCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_GetPageCount(__IntPtr document);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_LoadPage", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDF_LoadPage(__IntPtr document, int page_index);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_GetPageWidthF", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float FPDF_GetPageWidthF(__IntPtr page);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_GetPageWidth", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern double FPDF_GetPageWidth(__IntPtr page);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_GetPageHeightF", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float FPDF_GetPageHeightF(__IntPtr page);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_GetPageHeight", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern double FPDF_GetPageHeight(__IntPtr page);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_GetPageBoundingBox", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::PdfLibCore.Types.FPDF_BOOL FPDF_GetPageBoundingBox(__IntPtr page, __IntPtr rect);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_GetPageSizeByIndexF", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::PdfLibCore.Types.FPDF_BOOL FPDF_GetPageSizeByIndexF(__IntPtr document, int page_index, __IntPtr size);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_GetPageSizeByIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_GetPageSizeByIndex(__IntPtr document, int page_index, double* width, double* height);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_RenderPageBitmap", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDF_RenderPageBitmap(__IntPtr bitmap, __IntPtr page, int start_x, int start_y, int size_x, int size_y, int rotate, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_RenderPageBitmapWithMatrix", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDF_RenderPageBitmapWithMatrix(__IntPtr bitmap, __IntPtr page, __IntPtr matrix, __IntPtr clipping, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_ClosePage", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDF_ClosePage(__IntPtr page);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_CloseDocument", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDF_CloseDocument(__IntPtr document);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_DeviceToPage", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::PdfLibCore.Types.FPDF_BOOL FPDF_DeviceToPage(__IntPtr page, int start_x, int start_y, int size_x, int size_y, int rotate, int device_x, int device_y, double* page_x, double* page_y);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_PageToDevice", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::PdfLibCore.Types.FPDF_BOOL FPDF_PageToDevice(__IntPtr page, int start_x, int start_y, int size_x, int size_y, int rotate, double page_x, double page_y, int* device_x, int* device_y);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFBitmap_Create", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFBitmap_Create(int width, int height, int alpha);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFBitmap_CreateEx", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFBitmap_CreateEx(int width, int height, int format, __IntPtr first_scan, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFBitmap_GetFormat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFBitmap_GetFormat(__IntPtr bitmap);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFBitmap_FillRect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDFBitmap_FillRect(__IntPtr bitmap, int left, int top, int width, int height, long color);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFBitmap_GetBuffer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFBitmap_GetBuffer(__IntPtr bitmap);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFBitmap_GetWidth", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFBitmap_GetWidth(__IntPtr bitmap);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFBitmap_GetHeight", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFBitmap_GetHeight(__IntPtr bitmap);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFBitmap_GetStride", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFBitmap_GetStride(__IntPtr bitmap);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFBitmap_Destroy", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDFBitmap_Destroy(__IntPtr bitmap);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_VIEWERREF_GetPrintScaling", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::PdfLibCore.Types.FPDF_BOOL FPDF_VIEWERREF_GetPrintScaling(__IntPtr document);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_VIEWERREF_GetNumCopies", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_VIEWERREF_GetNumCopies(__IntPtr document);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_VIEWERREF_GetPrintPageRange", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDF_VIEWERREF_GetPrintPageRange(__IntPtr document);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_VIEWERREF_GetPrintPageRangeCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong FPDF_VIEWERREF_GetPrintPageRangeCount(__IntPtr pagerange);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_VIEWERREF_GetPrintPageRangeElement", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_VIEWERREF_GetPrintPageRangeElement(__IntPtr pagerange, ulong index);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_VIEWERREF_GetDuplex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::PdfLibCore.Generated.FPDF_DUPLEXTYPE_ FPDF_VIEWERREF_GetDuplex(__IntPtr document);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_VIEWERREF_GetName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDF_VIEWERREF_GetName(__IntPtr document, string key, sbyte* buffer, uint length);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_CountNamedDests", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern long FPDF_CountNamedDests(__IntPtr document);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_GetNamedDestByName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDF_GetNamedDestByName(__IntPtr document, string name);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_GetNamedDest", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDF_GetNamedDest(__IntPtr document, int index, __IntPtr buffer, int* buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_GetXFAPacketCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDF_GetXFAPacketCount(__IntPtr document);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_GetXFAPacketName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDF_GetXFAPacketName(__IntPtr document, int index, __IntPtr buffer, uint buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_GetXFAPacketContent", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::PdfLibCore.Types.FPDF_BOOL FPDF_GetXFAPacketContent(__IntPtr document, int index, __IntPtr buffer, uint buflen, uint* out_buflen);
        }

        /// <summary>Initialize the FPDFSDK library</summary>
        /// <remarks>
        /// Convenience function to call FPDF_InitLibraryWithConfig() for
        /// backwards compatibility purposes. This will be deprecated in the
        /// future.
        /// </remarks>
        public static void FPDF_InitLibrary()
        {
            __Internal.FPDF_InitLibrary();
        }

        /// <summary>Initialize the FPDFSDK library</summary>
        /// <param name="config">configuration information as above.</param>
        /// <remarks>You have to call this function before you can call any PDF processing functions.</remarks>
        public static void FPDF_InitLibraryWithConfig(global::PdfLibCore.Generated.FPDF_LIBRARY_CONFIG_ config)
        {
            var __arg0 = config is null ? __IntPtr.Zero : config.__Instance;
            __Internal.FPDF_InitLibraryWithConfig(__arg0);
        }

        /// <summary>Release all resources allocated by the FPDFSDK library.</summary>
        /// <remarks>
        /// You can call this function to release all memory blocks allocated by
        /// the library.
        /// After this function is called, you should not call any PDF
        /// processing functions.
        /// </remarks>
        public static void FPDF_DestroyLibrary()
        {
            __Internal.FPDF_DestroyLibrary();
        }

        /// <summary>Set the policy for the sandbox environment.</summary>
        /// <param name="policy">The specified policy for setting, for example: FPDF_POLICY_MACHINETIME_ACCESS.</param>
        /// <param name="enable">True to enable, false to disable the policy.</param>
        public static void FPDF_SetSandBoxPolicy(long policy, global::PdfLibCore.Types.FPDF_BOOL enable)
        {
            __Internal.FPDF_SetSandBoxPolicy(policy, enable);
        }

        /// <summary>Open and load a PDF document.</summary>
        /// <param name="file_path">Path to the PDF file (including extension).</param>
        /// <param name="password">
        /// A string used as the password for the PDF file.
        /// If no password is needed, empty or NULL can be used.
        /// See comments below regarding the encoding.
        /// </param>
        /// <remarks>
        /// Loaded document can be closed by FPDF_CloseDocument().
        /// If this function fails, you can use FPDF_GetLastError() to retrieve
        /// the reason why it failed.
        /// The encoding for |file_path| is UTF-8.
        /// The encoding for |password| can be either UTF-8 or Latin-1. PDFs,
        /// depending on the security handler revision, will only accept one or
        /// the other encoding. If |password|'s encoding and the PDF's expected
        /// encoding do not match, FPDF_LoadDocument() will automatically
        /// convert |password| to the other encoding.
        /// </remarks>
        /// <returns>A handle to the loaded document, or NULL on failure.</returns>
        public static global::PdfLibCore.Generated.FPDF_Document FPDF_LoadDocument(string file_path, string password)
        {
            var ___ret = __Internal.FPDF_LoadDocument(file_path, password);
            var __result0 = global::PdfLibCore.Generated.FPDF_Document.__CreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Open and load a PDF document from memory.</summary>
        /// <param name="data_buf">Pointer to a buffer containing the PDF document.</param>
        /// <param name="size">Number of bytes in the PDF document.</param>
        /// <param name="password">A string used as the password for the PDF file. If no password is needed, empty or NULL can be used.</param>
        /// <remarks>
        /// The memory buffer must remain valid when the document is open.
        /// The loaded document can be closed by FPDF_CloseDocument.
        /// If this function fails, you can use FPDF_GetLastError() to retrieve
        /// the reason why it failed.
        /// See the comments for FPDF_LoadDocument() regarding the encoding for
        /// |password|.
        /// Notes:
        /// If PDFium is built with the XFA module, the application should call
        /// FPDF_LoadXFA() function after the PDF document loaded to support XFA
        /// fields defined in the fpdfformfill.h file.
        /// </remarks>
        /// <returns>A handle to the loaded document, or NULL on failure.</returns>
        public static global::PdfLibCore.Generated.FPDF_Document FPDF_LoadMemDocument(__IntPtr data_buf, int size, string password)
        {
            var ___ret = __Internal.FPDF_LoadMemDocument(data_buf, size, password);
            var __result0 = global::PdfLibCore.Generated.FPDF_Document.__CreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Open and load a PDF document from memory.</summary>
        /// <param name="data_buf">Pointer to a buffer containing the PDF document.</param>
        /// <param name="size">Number of bytes in the PDF document.</param>
        /// <param name="password">A string used as the password for the PDF file. If no password is needed, empty or NULL can be used.</param>
        /// <remarks>
        /// The memory buffer must remain valid when the document is open.
        /// The loaded document can be closed by FPDF_CloseDocument.
        /// If this function fails, you can use FPDF_GetLastError() to retrieve
        /// the reason why it failed.
        /// See the comments for FPDF_LoadDocument() regarding the encoding for
        /// |password|.
        /// Notes:
        /// If PDFium is built with the XFA module, the application should call
        /// FPDF_LoadXFA() function after the PDF document loaded to support XFA
        /// fields defined in the fpdfformfill.h file.
        /// </remarks>
        /// <returns>A handle to the loaded document, or NULL on failure.</returns>
        public static global::PdfLibCore.Generated.FPDF_Document FPDF_LoadMemDocument64(__IntPtr data_buf, ulong size, string password)
        {
            var ___ret = __Internal.FPDF_LoadMemDocument64(data_buf, size, password);
            var __result0 = global::PdfLibCore.Generated.FPDF_Document.__CreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Load PDF document from a custom access descriptor.</summary>
        /// <param name="pFileAccess">A structure for accessing the file.</param>
        /// <param name="password">Optional password for decrypting the PDF file.</param>
        /// <remarks>
        /// The application must keep the file resources |pFileAccess| points to
        /// valid until the returned FPDF_DOCUMENT is closed. |pFileAccess|
        /// itself does not need to outlive the FPDF_DOCUMENT.
        /// The loaded document can be closed with FPDF_CloseDocument().
        /// See the comments for FPDF_LoadDocument() regarding the encoding for
        /// |password|.
        /// Notes:
        /// If PDFium is built with the XFA module, the application should call
        /// FPDF_LoadXFA() function after the PDF document loaded to support XFA
        /// fields defined in the fpdfformfill.h file.
        /// </remarks>
        /// <returns>A handle to the loaded document, or NULL on failure.</returns>
        public static global::PdfLibCore.Generated.FPDF_Document FPDF_LoadCustomDocument(global::PdfLibCore.Generated.FPDF_FILEACCESS pFileAccess, string password)
        {
            var __arg0 = pFileAccess is null ? __IntPtr.Zero : pFileAccess.__Instance;
            var ___ret = __Internal.FPDF_LoadCustomDocument(__arg0, password);
            var __result0 = global::PdfLibCore.Generated.FPDF_Document.__CreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the file version of the given PDF document.</summary>
        /// <param name="doc">Handle to a document.</param>
        /// <param name="fileVersion">The PDF file version. File version: 14 for 1.4, 15 for 1.5, ...</param>
        /// <remarks>If the document was created by FPDF_CreateNewDocument, then this function will always fail.</remarks>
        /// <returns>True if succeeds, false otherwise.</returns>
        public static global::PdfLibCore.Types.FPDF_BOOL FPDF_GetFileVersion(global::PdfLibCore.Generated.FPDF_Document doc, ref int fileVersion)
        {
            var __arg0 = doc is null ? __IntPtr.Zero : doc.__Instance;
            fixed (int* __fileVersion1 = &fileVersion)
            {
                var __arg1 = __fileVersion1;
                var ___ret = __Internal.FPDF_GetFileVersion(__arg0, __arg1);
                return ___ret;
            }
        }

        /// <summary>Get last error code when a function fails.</summary>
        /// <remarks>
        /// If the previous SDK call succeeded, the return value of this
        /// function is not defined. This function only works in conjunction
        /// with APIs that mention FPDF_GetLastError() in their documentation.
        /// </remarks>
        /// <returns>A 32-bit integer indicating error code as defined above.</returns>
        public static global::PdfLibCore.Types.FPDF_ERR FPDF_GetLastError()
        {
            var ___ret = __Internal.FPDF_GetLastError();
            return ___ret;
        }

        /// <summary>Whether the document's cross reference table is valid or not.</summary>
        /// <param name="document">Handle to a document. Returned by FPDF_LoadDocument.</param>
        /// <remarks>The return value can change over time as the PDF parser evolves.</remarks>
        /// <returns>
        /// True if the PDF parser did not encounter problems parsing the cross
        /// reference table. False if the parser could not parse the cross
        /// reference table and the table had to be rebuild from other data
        /// within the document.
        /// </returns>
        public static global::PdfLibCore.Types.FPDF_BOOL FPDF_DocumentHasValidCrossReferenceTable(global::PdfLibCore.Generated.FPDF_Document document)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var ___ret = __Internal.FPDF_DocumentHasValidCrossReferenceTable(__arg0);
            return ___ret;
        }

        /// <summary>Get the byte offsets of trailer ends.</summary>
        /// <param name="document">Handle to document. Returned by FPDF_LoadDocument().</param>
        /// <param name="buffer">The address of a buffer that receives the byte offsets.</param>
        /// <param name="length">The size, in ints, of |buffer|.</param>
        /// <returns>
        /// Returns the number of ints in the buffer on success, 0 on error.
        /// |buffer| is an array of integers that describes the exact byte offsets of the
        /// trailer ends in the document. If |length| is less than the returned length,
        /// or |document| or |buffer| is NULL, |buffer| will not be modified.
        /// </returns>
        public static uint FPDF_GetTrailerEnds(global::PdfLibCore.Generated.FPDF_Document document, ref uint buffer, uint length)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            fixed (uint* __buffer1 = &buffer)
            {
                var __arg1 = __buffer1;
                var ___ret = __Internal.FPDF_GetTrailerEnds(__arg0, __arg1, length);
                return ___ret;
            }
        }

        /// <summary>Get file permission flags of the document.</summary>
        /// <param name="document">Handle to a document. Returned by FPDF_LoadDocument.</param>
        /// <returns>
        /// A 32-bit integer indicating permission flags. Please refer to the
        /// PDF Reference for detailed descriptions. If the document is not
        /// protected, 0xffffffff will be returned.
        /// </returns>
        public static uint FPDF_GetDocPermissions(global::PdfLibCore.Generated.FPDF_Document document)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var ___ret = __Internal.FPDF_GetDocPermissions(__arg0);
            return ___ret;
        }

        /// <summary>Get the revision for the security handler.</summary>
        /// <param name="document">Handle to a document. Returned by FPDF_LoadDocument.</param>
        /// <returns>
        /// The security handler revision number. Please refer to the PDF
        /// Reference for a detailed description. If the document is not
        /// protected, -1 will be returned.
        /// </returns>
        public static int FPDF_GetSecurityHandlerRevision(global::PdfLibCore.Generated.FPDF_Document document)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var ___ret = __Internal.FPDF_GetSecurityHandlerRevision(__arg0);
            return ___ret;
        }

        /// <summary>Get total number of pages in the document.</summary>
        /// <param name="document">Handle to document. Returned by FPDF_LoadDocument.</param>
        /// <returns>Total number of pages in the document.</returns>
        public static int FPDF_GetPageCount(global::PdfLibCore.Generated.FPDF_Document document)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var ___ret = __Internal.FPDF_GetPageCount(__arg0);
            return ___ret;
        }

        /// <summary>Load a page inside the document.</summary>
        /// <param name="document">Handle to document. Returned by FPDF_LoadDocument</param>
        /// <param name="page_index">Index number of the page. 0 for the first page.</param>
        /// <remarks>
        /// The loaded page can be rendered to devices using FPDF_RenderPage.
        /// The loaded page can be closed using FPDF_ClosePage.
        /// </remarks>
        /// <returns>A handle to the loaded page, or NULL if page load fails.</returns>
        public static global::PdfLibCore.Generated.FPDF_Page FPDF_LoadPage(global::PdfLibCore.Generated.FPDF_Document document, int page_index)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var ___ret = __Internal.FPDF_LoadPage(__arg0, page_index);
            var __result0 = global::PdfLibCore.Generated.FPDF_Page.__CreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get page width.</summary>
        /// <param name="page">Handle to the page. Returned by FPDF_LoadPage().</param>
        /// <returns>
        /// Page width (excluding non-displayable area) measured in points.
        /// One point is 1/72 inch (around 0.3528 mm).
        /// </returns>
        public static float FPDF_GetPageWidthF(global::PdfLibCore.Generated.FPDF_Page page)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var ___ret = __Internal.FPDF_GetPageWidthF(__arg0);
            return ___ret;
        }

        /// <summary>Get page width.</summary>
        /// <param name="page">Handle to the page. Returned by FPDF_LoadPage.</param>
        /// <returns>
        /// Page width (excluding non-displayable area) measured in points.
        /// One point is 1/72 inch (around 0.3528 mm).
        /// Note:
        /// Prefer FPDF_GetPageWidthF() above. This will be deprecated in the
        /// future.
        /// </returns>
        public static double FPDF_GetPageWidth(global::PdfLibCore.Generated.FPDF_Page page)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var ___ret = __Internal.FPDF_GetPageWidth(__arg0);
            return ___ret;
        }

        /// <summary>Get page height.</summary>
        /// <param name="page">Handle to the page. Returned by FPDF_LoadPage().</param>
        /// <returns>
        /// Page height (excluding non-displayable area) measured in points.
        /// One point is 1/72 inch (around 0.3528 mm)
        /// </returns>
        public static float FPDF_GetPageHeightF(global::PdfLibCore.Generated.FPDF_Page page)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var ___ret = __Internal.FPDF_GetPageHeightF(__arg0);
            return ___ret;
        }

        /// <summary>Get page height.</summary>
        /// <param name="page">Handle to the page. Returned by FPDF_LoadPage.</param>
        /// <returns>
        /// Page height (excluding non-displayable area) measured in points.
        /// One point is 1/72 inch (around 0.3528 mm)
        /// Note:
        /// Prefer FPDF_GetPageHeightF() above. This will be deprecated in the
        /// future.
        /// </returns>
        public static double FPDF_GetPageHeight(global::PdfLibCore.Generated.FPDF_Page page)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var ___ret = __Internal.FPDF_GetPageHeight(__arg0);
            return ___ret;
        }

        /// <summary>Get the bounding box of the page. This is the intersection between its media box and its crop box.</summary>
        /// <param name="page">Handle to the page. Returned by FPDF_LoadPage.</param>
        /// <param name="rect">Pointer to a rect to receive the page bounding box. On an error, |rect| won't be filled.</param>
        /// <returns>True for success.</returns>
        public static global::PdfLibCore.Types.FPDF_BOOL FPDF_GetPageBoundingBox(global::PdfLibCore.Generated.FPDF_Page page, global::PdfLibCore.Generated.FS_RECTF_ rect)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var __arg1 = rect is null ? __IntPtr.Zero : rect.__Instance;
            var ___ret = __Internal.FPDF_GetPageBoundingBox(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Get the size of the page at the given index.</summary>
        /// <param name="document">Handle to document. Returned by FPDF_LoadDocument().</param>
        /// <param name="page_index">Page index, zero for the first page.</param>
        /// <param name="size">Pointer to a FS_SIZEF to receive the page size. (in points).</param>
        /// <returns>Non-zero for success. 0 for error (document or page not found).</returns>
        public static global::PdfLibCore.Types.FPDF_BOOL FPDF_GetPageSizeByIndexF(global::PdfLibCore.Generated.FPDF_Document document, int page_index, global::PdfLibCore.Generated.FS_SIZEF_ size)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __arg2 = size is null ? __IntPtr.Zero : size.__Instance;
            var ___ret = __Internal.FPDF_GetPageSizeByIndexF(__arg0, page_index, __arg2);
            return ___ret;
        }

        /// <summary>Get the size of the page at the given index.</summary>
        /// <param name="document">Handle to document. Returned by FPDF_LoadDocument.</param>
        /// <param name="page_index">Page index, zero for the first page.</param>
        /// <param name="width">Pointer to a double to receive the page width (in points).</param>
        /// <param name="height">Pointer to a double to receive the page height (in points).</param>
        /// <returns>
        /// Non-zero for success. 0 for error (document or page not found).
        /// Note:
        /// Prefer FPDF_GetPageSizeByIndexF() above. This will be deprecated in
        /// the future.
        /// </returns>
        public static int FPDF_GetPageSizeByIndex(global::PdfLibCore.Generated.FPDF_Document document, int page_index, ref double width, ref double height)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            fixed (double* __width2 = &width)
            {
                var __arg2 = __width2;
                fixed (double* __height3 = &height)
                {
                    var __arg3 = __height3;
                    var ___ret = __Internal.FPDF_GetPageSizeByIndex(__arg0, page_index, __arg2, __arg3);
                    return ___ret;
                }
            }
        }

        /// <summary>Render contents of a page to a device independent bitmap.</summary>
        /// <param name="bitmap">
        /// Handle to the device independent bitmap (as the
        /// output buffer). The bitmap handle can be created
        /// by FPDFBitmap_Create or retrieved from an image
        /// object by FPDFImageObj_GetBitmap.
        /// </param>
        /// <param name="page">Handle to the page. Returned by FPDF_LoadPage</param>
        /// <param name="start_x">Left pixel position of the display area in bitmap coordinates.</param>
        /// <param name="start_y">Top pixel position of the display area in bitmap coordinates.</param>
        /// <param name="size_x">Horizontal size (in pixels) for displaying the page.</param>
        /// <param name="size_y">Vertical size (in pixels) for displaying the page.</param>
        /// <param name="rotate">
        /// Page orientation:
        /// 0 (normal)
        /// 1 (rotated 90 degrees clockwise)
        /// 2 (rotated 180 degrees)
        /// 3 (rotated 90 degrees counter-clockwise)
        /// </param>
        /// <param name="flags">
        /// 0 for normal display, or combination of the Page
        /// Rendering flags defined above. With the FPDF_ANNOT
        /// flag, it renders all annotations that do not require
        /// user-interaction, which are all annotations except
        /// widget and popup annotations.
        /// </param>
        public static void FPDF_RenderPageBitmap(global::PdfLibCore.Generated.FPDF_Bitmap bitmap, global::PdfLibCore.Generated.FPDF_Page page, int start_x, int start_y, int size_x, int size_y, int rotate, int flags)
        {
            var __arg0 = bitmap is null ? __IntPtr.Zero : bitmap.__Instance;
            var __arg1 = page is null ? __IntPtr.Zero : page.__Instance;
            __Internal.FPDF_RenderPageBitmap(__arg0, __arg1, start_x, start_y, size_x, size_y, rotate, flags);
        }

        /// <summary>Render contents of a page to a device independent bitmap.</summary>
        /// <param name="bitmap">
        /// Handle to the device independent bitmap (as the
        /// output buffer). The bitmap handle can be created
        /// by FPDFBitmap_Create or retrieved by
        /// FPDFImageObj_GetBitmap.
        /// </param>
        /// <param name="page">Handle to the page. Returned by FPDF_LoadPage.</param>
        /// <param name="matrix">The transform matrix, which must be invertible. See PDF Reference 1.7, 4.2.2 Common Transformations.</param>
        /// <param name="clipping">The rect to clip to in device coords.</param>
        /// <param name="flags">
        /// 0 for normal display, or combination of the Page
        /// Rendering flags defined above. With the FPDF_ANNOT
        /// flag, it renders all annotations that do not require
        /// user-interaction, which are all annotations except
        /// widget and popup annotations.
        /// </param>
        public static void FPDF_RenderPageBitmapWithMatrix(global::PdfLibCore.Generated.FPDF_Bitmap bitmap, global::PdfLibCore.Generated.FPDF_Page page, global::PdfLibCore.Generated.FS_MATRIX_ matrix, global::PdfLibCore.Generated.FS_RECTF_ clipping, int flags)
        {
            var __arg0 = bitmap is null ? __IntPtr.Zero : bitmap.__Instance;
            var __arg1 = page is null ? __IntPtr.Zero : page.__Instance;
            var __arg2 = matrix is null ? __IntPtr.Zero : matrix.__Instance;
            var __arg3 = clipping is null ? __IntPtr.Zero : clipping.__Instance;
            __Internal.FPDF_RenderPageBitmapWithMatrix(__arg0, __arg1, __arg2, __arg3, flags);
        }

        /// <summary>Close a loaded PDF page.</summary>
        /// <param name="page">Handle to the loaded page.</param>
        public static void FPDF_ClosePage(global::PdfLibCore.Generated.FPDF_Page page)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            __Internal.FPDF_ClosePage(__arg0);
        }

        /// <summary>Close a loaded PDF document.</summary>
        /// <param name="document">Handle to the loaded document.</param>
        public static void FPDF_CloseDocument(global::PdfLibCore.Generated.FPDF_Document document)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            __Internal.FPDF_CloseDocument(__arg0);
        }

        /// <summary>Convert the screen coordinates of a point to page coordinates.</summary>
        /// <param name="page">Handle to the page. Returned by FPDF_LoadPage.</param>
        /// <param name="start_x">Left pixel position of the display area in device coordinates.</param>
        /// <param name="start_y">Top pixel position of the display area in device coordinates.</param>
        /// <param name="size_x">Horizontal size (in pixels) for displaying the page.</param>
        /// <param name="size_y">Vertical size (in pixels) for displaying the page.</param>
        /// <param name="rotate">
        /// Page orientation:
        /// 0 (normal)
        /// 1 (rotated 90 degrees clockwise)
        /// 2 (rotated 180 degrees)
        /// 3 (rotated 90 degrees counter-clockwise)
        /// </param>
        /// <param name="device_x">X value in device coordinates to be converted.</param>
        /// <param name="device_y">Y value in device coordinates to be converted.</param>
        /// <param name="page_x">A pointer to a double receiving the converted X value in page coordinates.</param>
        /// <param name="page_y">A pointer to a double receiving the converted Y value in page coordinates.</param>
        /// <remarks>
        /// The page coordinate system has its origin at the left-bottom corner
        /// of the page, with the X-axis on the bottom going to the right, and
        /// the Y-axis on the left side going up.
        /// NOTE: this coordinate system can be altered when you zoom, scroll,
        /// or rotate a page, however, a point on the page should always have
        /// the same coordinate values in the page coordinate system.
        /// The device coordinate system is device dependent. For screen device,
        /// its origin is at the left-top corner of the window. However this
        /// origin can be altered by the Windows coordinate transformation
        /// utilities.
        /// You must make sure the start_x, start_y, size_x, size_y
        /// and rotate parameters have exactly same values as you used in
        /// the FPDF_RenderPage() function call.
        /// </remarks>
        /// <returns>
        /// Returns true if the conversion succeeds, and |page_x| and |page_y|
        /// successfully receives the converted coordinates.
        /// </returns>
        public static global::PdfLibCore.Types.FPDF_BOOL FPDF_DeviceToPage(global::PdfLibCore.Generated.FPDF_Page page, int start_x, int start_y, int size_x, int size_y, int rotate, int device_x, int device_y, ref double page_x, ref double page_y)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            fixed (double* __page_x8 = &page_x)
            {
                var __arg8 = __page_x8;
                fixed (double* __page_y9 = &page_y)
                {
                    var __arg9 = __page_y9;
                    var ___ret = __Internal.FPDF_DeviceToPage(__arg0, start_x, start_y, size_x, size_y, rotate, device_x, device_y, __arg8, __arg9);
                    return ___ret;
                }
            }
        }

        /// <summary>Convert the page coordinates of a point to screen coordinates.</summary>
        /// <param name="page">Handle to the page. Returned by FPDF_LoadPage.</param>
        /// <param name="start_x">Left pixel position of the display area in device coordinates.</param>
        /// <param name="start_y">Top pixel position of the display area in device coordinates.</param>
        /// <param name="size_x">Horizontal size (in pixels) for displaying the page.</param>
        /// <param name="size_y">Vertical size (in pixels) for displaying the page.</param>
        /// <param name="rotate">
        /// Page orientation:
        /// 0 (normal)
        /// 1 (rotated 90 degrees clockwise)
        /// 2 (rotated 180 degrees)
        /// 3 (rotated 90 degrees counter-clockwise)
        /// </param>
        /// <param name="page_x">X value in page coordinates.</param>
        /// <param name="page_y">Y value in page coordinate.</param>
        /// <param name="device_x">A pointer to an integer receiving the result X value in device coordinates.</param>
        /// <param name="device_y">A pointer to an integer receiving the result Y value in device coordinates.</param>
        /// <remarks>See comments for FPDF_DeviceToPage().</remarks>
        /// <returns>
        /// Returns true if the conversion succeeds, and |device_x| and
        /// |device_y| successfully receives the converted coordinates.
        /// </returns>
        public static global::PdfLibCore.Types.FPDF_BOOL FPDF_PageToDevice(global::PdfLibCore.Generated.FPDF_Page page, int start_x, int start_y, int size_x, int size_y, int rotate, double page_x, double page_y, ref int device_x, ref int device_y)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            fixed (int* __device_x8 = &device_x)
            {
                var __arg8 = __device_x8;
                fixed (int* __device_y9 = &device_y)
                {
                    var __arg9 = __device_y9;
                    var ___ret = __Internal.FPDF_PageToDevice(__arg0, start_x, start_y, size_x, size_y, rotate, page_x, page_y, __arg8, __arg9);
                    return ___ret;
                }
            }
        }

        /// <summary>Create a device independent bitmap (FXDIB).</summary>
        /// <param name="width">The number of pixels in width for the bitmap. Must be greater than 0.</param>
        /// <param name="height">The number of pixels in height for the bitmap. Must be greater than 0.</param>
        /// <param name="alpha">A flag indicating whether the alpha channel is used. Non-zero for using alpha, zero for not using.</param>
        /// <remarks>
        /// The bitmap always uses 4 bytes per pixel. The first byte is always
        /// double word aligned.
        /// The byte order is BGRx (the last byte unused if no alpha channel) or
        /// BGRA.
        /// The pixels in a horizontal line are stored side by side, with the
        /// left most pixel stored first (with lower memory address).
        /// Each line uses width * 4 bytes.
        /// Lines are stored one after another, with the top most line stored
        /// first. There is no gap between adjacent lines.
        /// This function allocates enough memory for holding all pixels in the
        /// bitmap, but it doesn't initialize the buffer. Applications can use
        /// FPDFBitmap_FillRect() to fill the bitmap using any color. If the OS
        /// allows it, this function can allocate up to 4 GB of memory.
        /// </remarks>
        /// <returns>The created bitmap handle, or NULL if a parameter error or out of memory.</returns>
        public static global::PdfLibCore.Generated.FPDF_Bitmap FPDFBitmap_Create(int width, int height, int alpha)
        {
            var ___ret = __Internal.FPDFBitmap_Create(width, height, alpha);
            var __result0 = global::PdfLibCore.Generated.FPDF_Bitmap.__CreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Create a device independent bitmap (FXDIB)</summary>
        /// <param name="width">The number of pixels in width for the bitmap. Must be greater than 0.</param>
        /// <param name="height">The number of pixels in height for the bitmap. Must be greater than 0.</param>
        /// <param name="format">A number indicating for bitmap format, as defined above.</param>
        /// <param name="first_scan">
        /// A pointer to the first byte of the first line if
        /// using an external buffer. If this parameter is NULL,
        /// then a new buffer will be created.
        /// </param>
        /// <param name="stride">
        /// Number of bytes for each scan line. The value must
        /// be 0 or greater. When the value is 0,
        /// FPDFBitmap_CreateEx() will automatically calculate
        /// the appropriate value using |width| and |format|.
        /// When using an external buffer, it is recommended for
        /// the caller to pass in the value.
        /// When not using an external buffer, it is recommended
        /// for the caller to pass in 0.
        /// </param>
        /// <remarks>
        /// Similar to FPDFBitmap_Create function, but allows for more formats
        /// and an external buffer is supported. The bitmap created by this
        /// function can be used in any place that a FPDF_BITMAP handle is
        /// required.
        /// If an external buffer is used, then the caller should destroy the
        /// buffer. FPDFBitmap_Destroy() will not destroy the buffer.
        /// It is recommended to use FPDFBitmap_GetStride() to get the stride
        /// value.
        /// </remarks>
        /// <returns>The bitmap handle, or NULL if parameter error or out of memory.</returns>
        public static global::PdfLibCore.Generated.FPDF_Bitmap FPDFBitmap_CreateEx(int width, int height, int format, __IntPtr first_scan, int stride)
        {
            var ___ret = __Internal.FPDFBitmap_CreateEx(width, height, format, first_scan, stride);
            var __result0 = global::PdfLibCore.Generated.FPDF_Bitmap.__CreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the format of the bitmap.</summary>
        /// <param name="bitmap">Handle to the bitmap. Returned by FPDFBitmap_Create or FPDFImageObj_GetBitmap.</param>
        /// <remarks>
        /// Only formats supported by FPDFBitmap_CreateEx are supported by this
        /// function; see the list of such formats above.
        /// </remarks>
        /// <returns>The format of the bitmap.</returns>
        public static int FPDFBitmap_GetFormat(global::PdfLibCore.Generated.FPDF_Bitmap bitmap)
        {
            var __arg0 = bitmap is null ? __IntPtr.Zero : bitmap.__Instance;
            var ___ret = __Internal.FPDFBitmap_GetFormat(__arg0);
            return ___ret;
        }

        /// <summary>Fill a rectangle in a bitmap.</summary>
        /// <param name="bitmap">The handle to the bitmap. Returned by FPDFBitmap_Create.</param>
        /// <param name="left">The left position. Starting from 0 at the left-most pixel.</param>
        /// <param name="top">The top position. Starting from 0 at the top-most line.</param>
        /// <param name="width">Width in pixels to be filled.</param>
        /// <param name="height">Height in pixels to be filled.</param>
        /// <param name="color">A 32-bit value specifing the color, in 8888 ARGB format.</param>
        /// <remarks>
        /// This function sets the color and (optionally) alpha value in the
        /// specified region of the bitmap.
        /// NOTE: If the alpha channel is used, this function does NOT
        /// composite the background with the source color, instead the
        /// background will be replaced by the source color and the alpha.
        /// If the alpha channel is not used, the alpha parameter is ignored.
        /// </remarks>
        public static void FPDFBitmap_FillRect(global::PdfLibCore.Generated.FPDF_Bitmap bitmap, int left, int top, int width, int height, long color)
        {
            var __arg0 = bitmap is null ? __IntPtr.Zero : bitmap.__Instance;
            __Internal.FPDFBitmap_FillRect(__arg0, left, top, width, height, color);
        }

        /// <summary>Get data buffer of a bitmap.</summary>
        /// <param name="bitmap">Handle to the bitmap. Returned by FPDFBitmap_Create or FPDFImageObj_GetBitmap.</param>
        /// <remarks>
        /// The stride may be more than width * number of bytes per pixel
        /// Applications can use this function to get the bitmap buffer pointer,
        /// then manipulate any color and/or alpha values for any pixels in the
        /// bitmap.
        /// Use FPDFBitmap_GetFormat() to find out the format of the data.
        /// </remarks>
        /// <returns>The pointer to the first byte of the bitmap buffer.</returns>
        public static __IntPtr FPDFBitmap_GetBuffer(global::PdfLibCore.Generated.FPDF_Bitmap bitmap)
        {
            var __arg0 = bitmap is null ? __IntPtr.Zero : bitmap.__Instance;
            var ___ret = __Internal.FPDFBitmap_GetBuffer(__arg0);
            return ___ret;
        }

        /// <summary>Get width of a bitmap.</summary>
        /// <param name="bitmap">Handle to the bitmap. Returned by FPDFBitmap_Create or FPDFImageObj_GetBitmap.</param>
        /// <returns>The width of the bitmap in pixels.</returns>
        public static int FPDFBitmap_GetWidth(global::PdfLibCore.Generated.FPDF_Bitmap bitmap)
        {
            var __arg0 = bitmap is null ? __IntPtr.Zero : bitmap.__Instance;
            var ___ret = __Internal.FPDFBitmap_GetWidth(__arg0);
            return ___ret;
        }

        /// <summary>Get height of a bitmap.</summary>
        /// <param name="bitmap">Handle to the bitmap. Returned by FPDFBitmap_Create or FPDFImageObj_GetBitmap.</param>
        /// <returns>The height of the bitmap in pixels.</returns>
        public static int FPDFBitmap_GetHeight(global::PdfLibCore.Generated.FPDF_Bitmap bitmap)
        {
            var __arg0 = bitmap is null ? __IntPtr.Zero : bitmap.__Instance;
            var ___ret = __Internal.FPDFBitmap_GetHeight(__arg0);
            return ___ret;
        }

        /// <summary>Get number of bytes for each line in the bitmap buffer.</summary>
        /// <param name="bitmap">Handle to the bitmap. Returned by FPDFBitmap_Create or FPDFImageObj_GetBitmap.</param>
        /// <remarks>The stride may be more than width * number of bytes per pixel.</remarks>
        /// <returns>The number of bytes for each line in the bitmap buffer.</returns>
        public static int FPDFBitmap_GetStride(global::PdfLibCore.Generated.FPDF_Bitmap bitmap)
        {
            var __arg0 = bitmap is null ? __IntPtr.Zero : bitmap.__Instance;
            var ___ret = __Internal.FPDFBitmap_GetStride(__arg0);
            return ___ret;
        }

        /// <summary>Destroy a bitmap and release all related buffers.</summary>
        /// <param name="bitmap">Handle to the bitmap. Returned by FPDFBitmap_Create or FPDFImageObj_GetBitmap.</param>
        /// <remarks>This function will not destroy any external buffers provided when the bitmap was created.</remarks>
        public static void FPDFBitmap_Destroy(global::PdfLibCore.Generated.FPDF_Bitmap bitmap)
        {
            var __arg0 = bitmap is null ? __IntPtr.Zero : bitmap.__Instance;
            __Internal.FPDFBitmap_Destroy(__arg0);
        }

        /// <summary>Whether the PDF document prefers to be scaled or not.</summary>
        /// <param name="document">Handle to the loaded document.</param>
        public static global::PdfLibCore.Types.FPDF_BOOL FPDF_VIEWERREF_GetPrintScaling(global::PdfLibCore.Generated.FPDF_Document document)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var ___ret = __Internal.FPDF_VIEWERREF_GetPrintScaling(__arg0);
            return ___ret;
        }

        /// <summary>Returns the number of copies to be printed.</summary>
        /// <param name="document">Handle to the loaded document.</param>
        /// <returns>The number of copies to be printed.</returns>
        public static int FPDF_VIEWERREF_GetNumCopies(global::PdfLibCore.Generated.FPDF_Document document)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var ___ret = __Internal.FPDF_VIEWERREF_GetNumCopies(__arg0);
            return ___ret;
        }

        /// <summary>Page numbers to initialize print dialog box when file is printed.</summary>
        /// <param name="document">Handle to the loaded document.</param>
        /// <returns>The print page range to be used for printing.</returns>
        public static global::PdfLibCore.Generated.FPDF_Pagerange FPDF_VIEWERREF_GetPrintPageRange(global::PdfLibCore.Generated.FPDF_Document document)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var ___ret = __Internal.FPDF_VIEWERREF_GetPrintPageRange(__arg0);
            var __result0 = global::PdfLibCore.Generated.FPDF_Pagerange.__CreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns the number of elements in a FPDF_PAGERANGE.</summary>
        /// <param name="pagerange">Handle to the page range.</param>
        /// <returns>The number of elements in the page range. Returns 0 on error.</returns>
        public static ulong FPDF_VIEWERREF_GetPrintPageRangeCount(global::PdfLibCore.Generated.FPDF_Pagerange pagerange)
        {
            var __arg0 = pagerange is null ? __IntPtr.Zero : pagerange.__Instance;
            var ___ret = __Internal.FPDF_VIEWERREF_GetPrintPageRangeCount(__arg0);
            return ___ret;
        }

        /// <summary>Returns an element from a FPDF_PAGERANGE.</summary>
        /// <param name="pagerange">Handle to the page range.</param>
        /// <param name="index">Index of the element.</param>
        /// <returns>The value of the element in the page range at a given index. Returns -1 on error.</returns>
        public static int FPDF_VIEWERREF_GetPrintPageRangeElement(global::PdfLibCore.Generated.FPDF_Pagerange pagerange, ulong index)
        {
            var __arg0 = pagerange is null ? __IntPtr.Zero : pagerange.__Instance;
            var ___ret = __Internal.FPDF_VIEWERREF_GetPrintPageRangeElement(__arg0, index);
            return ___ret;
        }

        /// <summary>Returns the paper handling option to be used when printing from the print dialog.</summary>
        /// <param name="document">Handle to the loaded document.</param>
        /// <returns>The paper handling option to be used when printing.</returns>
        public static global::PdfLibCore.Generated.FPDF_DUPLEXTYPE_ FPDF_VIEWERREF_GetDuplex(global::PdfLibCore.Generated.FPDF_Document document)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var ___ret = __Internal.FPDF_VIEWERREF_GetDuplex(__arg0);
            return ___ret;
        }

        /// <summary>Gets the contents for a viewer ref, with a given key. The value must be of type &quot;name&quot;.</summary>
        /// <param name="document">Handle to the loaded document.</param>
        /// <param name="key">Name of the key in the viewer pref dictionary, encoded in UTF-8.</param>
        /// <param name="buffer">A string to write the contents of the key to.</param>
        /// <param name="length">Length of the buffer.</param>
        /// <returns>
        /// The number of bytes in the contents, including the NULL terminator.
        /// Thus if the return value is 0, then that indicates an error, such
        /// as when |document| is invalid or |buffer| is NULL. If |length| is
        /// less than the returned length, or |buffer| is NULL, |buffer| will
        /// not be modified.
        /// </returns>
        public static uint FPDF_VIEWERREF_GetName(global::PdfLibCore.Generated.FPDF_Document document, string key, sbyte* buffer, uint length)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var ___ret = __Internal.FPDF_VIEWERREF_GetName(__arg0, key, buffer, length);
            return ___ret;
        }

        /// <summary>Get the count of named destinations in the PDF document.</summary>
        /// <param name="document">Handle to a document</param>
        /// <returns>The count of named destinations.</returns>
        public static long FPDF_CountNamedDests(global::PdfLibCore.Generated.FPDF_Document document)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var ___ret = __Internal.FPDF_CountNamedDests(__arg0);
            return ___ret;
        }

        /// <summary>Get a the destination handle for the given name.</summary>
        /// <param name="document">Handle to the loaded document.</param>
        /// <param name="name">The name of a destination.</param>
        /// <returns>The handle to the destination.</returns>
        public static global::PdfLibCore.Generated.FPDF_Dest FPDF_GetNamedDestByName(global::PdfLibCore.Generated.FPDF_Document document, string name)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var ___ret = __Internal.FPDF_GetNamedDestByName(__arg0, name);
            var __result0 = global::PdfLibCore.Generated.FPDF_Dest.__CreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the named destination by index.</summary>
        /// <param name="document">Handle to a document</param>
        /// <param name="index">The index of a named destination.</param>
        /// <param name="buffer">The buffer to store the destination name, used as wchar_t*.</param>
        /// <param name="buflen [in/out]">
        /// Size of the buffer in bytes on input,
        /// length of the result in bytes on output
        /// or -1 if the buffer is too small.
        /// </param>
        /// <remarks>
        /// Call this function twice to get the name of the named destination:
        /// 1) First time pass in |buffer| as NULL and get buflen.
        /// 2) Second time pass in allocated |buffer| and buflen to retrieve
        /// |buffer|, which should be used as wchar_t*.
        /// If buflen is not sufficiently large, it will be set to -1 upon
        /// return.
        /// </remarks>
        /// <returns>
        /// The destination handle for a given index, or NULL if there is no
        /// named destination corresponding to |index|.
        /// </returns>
        public static global::PdfLibCore.Generated.FPDF_Dest FPDF_GetNamedDest(global::PdfLibCore.Generated.FPDF_Document document, int index, __IntPtr buffer, ref int buflen)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            fixed (int* __buflen3 = &buflen)
            {
                var __arg3 = __buflen3;
                var ___ret = __Internal.FPDF_GetNamedDest(__arg0, index, buffer, __arg3);
                var __result0 = global::PdfLibCore.Generated.FPDF_Dest.__CreateInstance(___ret, false);
                return __result0;
            }
        }

        /// <summary>Get the number of valid packets in the XFA entry.</summary>
        /// <param name="document">Handle to the document.</param>
        /// <returns>The number of valid packets, or -1 on error.</returns>
        public static int FPDF_GetXFAPacketCount(global::PdfLibCore.Generated.FPDF_Document document)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var ___ret = __Internal.FPDF_GetXFAPacketCount(__arg0);
            return ___ret;
        }

        /// <summary>Get the name of a packet in the XFA array.</summary>
        /// <param name="document">Handle to the document.</param>
        /// <param name="index">Index number of the packet. 0 for the first packet.</param>
        /// <param name="buffer">Buffer for holding the name of the XFA packet.</param>
        /// <param name="buflen">Length of |buffer| in bytes.</param>
        /// <returns>
        /// The length of the packet name in bytes, or 0 on error.
        /// |document| must be valid and |index| must be in the range [0, N), where N is
        /// the value returned by FPDF_GetXFAPacketCount().
        /// |buffer| is only modified if it is non-NULL and |buflen| is greater than or
        /// equal to the length of the packet name. The packet name includes a
        /// terminating NUL character. |buffer| is unmodified on error.
        /// </returns>
        public static uint FPDF_GetXFAPacketName(global::PdfLibCore.Generated.FPDF_Document document, int index, __IntPtr buffer, uint buflen)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var ___ret = __Internal.FPDF_GetXFAPacketName(__arg0, index, buffer, buflen);
            return ___ret;
        }

        /// <summary>Get the content of a packet in the XFA array.</summary>
        /// <param name="document">Handle to the document.</param>
        /// <param name="index">Index number of the packet. 0 for the first packet.</param>
        /// <param name="buffer">Buffer for holding the content of the XFA packet.</param>
        /// <param name="buflen">Length of |buffer| in bytes.</param>
        /// <param name="out_buflen">
        /// Pointer to the variable that will receive the minimum
        /// buffer size needed to contain the content of the XFA
        /// packet.
        /// </param>
        /// <returns>
        /// Whether the operation succeeded or not.
        /// |document| must be valid and |index| must be in the range [0, N), where N is
        /// the value returned by FPDF_GetXFAPacketCount(). |out_buflen| must not be
        /// NULL. When the aforementioned arguments are valid, the operation succeeds,
        /// and |out_buflen| receives the content size. |buffer| is only modified if
        /// |buffer| is non-null and long enough to contain the content. Callers must
        /// check both the return value and the input |buflen| is no less than the
        /// returned |out_buflen| before using the data in |buffer|.
        /// </returns>
        public static global::PdfLibCore.Types.FPDF_BOOL FPDF_GetXFAPacketContent(global::PdfLibCore.Generated.FPDF_Document document, int index, __IntPtr buffer, uint buflen, ref uint out_buflen)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            fixed (uint* __out_buflen4 = &out_buflen)
            {
                var __arg4 = __out_buflen4;
                var ___ret = __Internal.FPDF_GetXFAPacketContent(__arg0, index, buffer, buflen, __arg4);
                return ___ret;
            }
        }
    }
}
