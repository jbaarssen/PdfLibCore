// Built from precompiled binaries at https://github.com/bblanchon/pdfium-binaries/releases/tag/chromium/5772
// Github release api https://api.github.com/repos/bblanchon/pdfium-binaries/releases/102934879
// PDFium version v115.0.5772.0 chromium/5772 [master]
// Built on: Wed, 17 May 2023 13:34:04 GMT

// ReSharper disable all
#pragma warning disable CS8500 // This takes the address of, gets the size of, or declares a pointer to a managed type

// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace PdfLibCore.Generated
{
    public static unsafe partial class Pdfium
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFText_LoadPage", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFText_LoadPage(__IntPtr page);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFText_ClosePage", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDFText_ClosePage(__IntPtr text_page);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFText_CountChars", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFText_CountChars(__IntPtr text_page);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFText_GetUnicode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFText_GetUnicode(__IntPtr text_page, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFText_IsGenerated", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFText_IsGenerated(__IntPtr text_page, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFText_HasUnicodeMapError", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFText_HasUnicodeMapError(__IntPtr text_page, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFText_GetFontSize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern double FPDFText_GetFontSize(__IntPtr text_page, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFText_GetFontInfo", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint FPDFText_GetFontInfo(__IntPtr text_page, int index, __IntPtr buffer, uint buflen, int* flags);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFText_GetFontWeight", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFText_GetFontWeight(__IntPtr text_page, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFText_GetTextRenderMode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::PdfLibCore.Generated.FPDF_TEXT_RENDERMODE FPDFText_GetTextRenderMode(__IntPtr text_page, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFText_GetFillColor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::PdfLibCore.Types.FPDF_BOOL FPDFText_GetFillColor(__IntPtr text_page, int index, uint* R, uint* G, uint* B, uint* A);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFText_GetStrokeColor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::PdfLibCore.Types.FPDF_BOOL FPDFText_GetStrokeColor(__IntPtr text_page, int index, uint* R, uint* G, uint* B, uint* A);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFText_GetCharAngle", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float FPDFText_GetCharAngle(__IntPtr text_page, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFText_GetCharBox", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::PdfLibCore.Types.FPDF_BOOL FPDFText_GetCharBox(__IntPtr text_page, int index, double* left, double* right, double* bottom, double* top);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFText_GetLooseCharBox", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::PdfLibCore.Types.FPDF_BOOL FPDFText_GetLooseCharBox(__IntPtr text_page, int index, __IntPtr rect);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFText_GetMatrix", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::PdfLibCore.Types.FPDF_BOOL FPDFText_GetMatrix(__IntPtr text_page, int index, __IntPtr matrix);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFText_GetCharOrigin", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::PdfLibCore.Types.FPDF_BOOL FPDFText_GetCharOrigin(__IntPtr text_page, int index, double* x, double* y);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFText_GetCharIndexAtPos", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFText_GetCharIndexAtPos(__IntPtr text_page, double x, double y, double xTolerance, double yTolerance);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFText_GetText", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFText_GetText(__IntPtr text_page, int start_index, int count, ushort* result);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFText_CountRects", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFText_CountRects(__IntPtr text_page, int start_index, int count);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFText_GetRect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::PdfLibCore.Types.FPDF_BOOL FPDFText_GetRect(__IntPtr text_page, int rect_index, double* left, double* top, double* right, double* bottom);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFText_GetBoundedText", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFText_GetBoundedText(__IntPtr text_page, double left, double top, double right, double bottom, ushort* buffer, int buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFText_FindStart", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFText_FindStart(__IntPtr text_page, string findwhat, uint flags, int start_index);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFText_FindNext", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::PdfLibCore.Types.FPDF_BOOL FPDFText_FindNext(__IntPtr handle);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFText_FindPrev", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::PdfLibCore.Types.FPDF_BOOL FPDFText_FindPrev(__IntPtr handle);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFText_GetSchResultIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFText_GetSchResultIndex(__IntPtr handle);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFText_GetSchCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFText_GetSchCount(__IntPtr handle);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFText_FindClose", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDFText_FindClose(__IntPtr handle);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFLink_LoadWebLinks", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FPDFLink_LoadWebLinks(__IntPtr text_page);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFLink_CountWebLinks", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFLink_CountWebLinks(__IntPtr link_page);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFLink_GetURL", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFLink_GetURL(__IntPtr link_page, int link_index, ushort* buffer, int buflen);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFLink_CountRects", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FPDFLink_CountRects(__IntPtr link_page, int link_index);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFLink_GetRect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::PdfLibCore.Types.FPDF_BOOL FPDFLink_GetRect(__IntPtr link_page, int link_index, int rect_index, double* left, double* top, double* right, double* bottom);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFLink_GetTextRange", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::PdfLibCore.Types.FPDF_BOOL FPDFLink_GetTextRange(__IntPtr link_page, int link_index, int* start_char_index, int* char_count);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDFLink_CloseWebLinks", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FPDFLink_CloseWebLinks(__IntPtr link_page);
        }

        /// <summary>Prepare information about all characters in a page.</summary>
        /// <param name="page">Handle to the page. Returned by FPDF_LoadPage function (in FPDFVIEW module).</param>
        /// <remarks>Application must call FPDFText_ClosePage to release the text page information.</remarks>
        /// <returns>A handle to the text page information structure. NULL if something goes wrong.</returns>
        public static global::PdfLibCore.Generated.FPDF_Textpage FPDFText_LoadPage(global::PdfLibCore.Generated.FPDF_Page page)
        {
            var __arg0 = page is null ? __IntPtr.Zero : page.__Instance;
            var ___ret = __Internal.FPDFText_LoadPage(__arg0);
            var __result0 = global::PdfLibCore.Generated.FPDF_Textpage.__CreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Release all resources allocated for a text page information structure.</summary>
        /// <param name="text_page">Handle to a text page information structure. Returned by FPDFText_LoadPage function.</param>
        public static void FPDFText_ClosePage(global::PdfLibCore.Generated.FPDF_Textpage text_page)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            __Internal.FPDFText_ClosePage(__arg0);
        }

        /// <summary>Get number of characters in a page.</summary>
        /// <param name="text_page">Handle to a text page information structure. Returned by FPDFText_LoadPage function.</param>
        /// <remarks>
        /// Characters in a page form a &quot;stream&quot;, inside the stream, each
        /// character has an index.
        /// We will use the index parameters in many of FPDFTEXT functions. The
        /// first character in the page
        /// has an index value of zero.
        /// </remarks>
        /// <returns>
        /// Number of characters in the page. Return -1 for error.
        /// Generated characters, like additional space characters, new line
        /// characters, are also counted.
        /// </returns>
        public static int FPDFText_CountChars(global::PdfLibCore.Generated.FPDF_Textpage text_page)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            var ___ret = __Internal.FPDFText_CountChars(__arg0);
            return ___ret;
        }

        /// <summary>Get Unicode of a character in a page.</summary>
        /// <param name="text_page">Handle to a text page information structure. Returned by FPDFText_LoadPage function.</param>
        /// <param name="index">Zero-based index of the character.</param>
        /// <returns>
        /// The Unicode of the particular character.
        /// If a character is not encoded in Unicode and Foxit engine can't
        /// convert to Unicode,
        /// the return value will be zero.
        /// </returns>
        public static uint FPDFText_GetUnicode(global::PdfLibCore.Generated.FPDF_Textpage text_page, int index)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            var ___ret = __Internal.FPDFText_GetUnicode(__arg0, index);
            return ___ret;
        }

        /// <summary>Get if a character in a page is generated by PDFium.</summary>
        /// <param name="text_page">Handle to a text page information structure. Returned by FPDFText_LoadPage function.</param>
        /// <param name="index">Zero-based index of the character.</param>
        /// <returns>
        /// 1 if the character is generated by PDFium.
        /// 0 if the character is not generated by PDFium.
        /// -1 if there was an error.
        /// </returns>
        public static int FPDFText_IsGenerated(global::PdfLibCore.Generated.FPDF_Textpage text_page, int index)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            var ___ret = __Internal.FPDFText_IsGenerated(__arg0, index);
            return ___ret;
        }

        /// <summary>Get if a character in a page has an invalid unicode mapping.</summary>
        /// <param name="text_page">Handle to a text page information structure. Returned by FPDFText_LoadPage function.</param>
        /// <param name="index">Zero-based index of the character.</param>
        /// <returns>
        /// 1 if the character has an invalid unicode mapping.
        /// 0 if the character has no known unicode mapping issues.
        /// -1 if there was an error.
        /// </returns>
        public static int FPDFText_HasUnicodeMapError(global::PdfLibCore.Generated.FPDF_Textpage text_page, int index)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            var ___ret = __Internal.FPDFText_HasUnicodeMapError(__arg0, index);
            return ___ret;
        }

        /// <summary>Get the font size of a particular character.</summary>
        /// <param name="text_page">Handle to a text page information structure. Returned by FPDFText_LoadPage function.</param>
        /// <param name="index">Zero-based index of the character.</param>
        /// <returns>
        /// The font size of the particular character, measured in points (about
        /// 1/72 inch). This is the typographic size of the font (so called
        /// &quot;em size&quot;).
        /// </returns>
        public static double FPDFText_GetFontSize(global::PdfLibCore.Generated.FPDF_Textpage text_page, int index)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            var ___ret = __Internal.FPDFText_GetFontSize(__arg0, index);
            return ___ret;
        }

        /// <summary>Get the font name and flags of a particular character.</summary>
        /// <param name="text_page">Handle to a text page information structure. Returned by FPDFText_LoadPage function.</param>
        /// <param name="index">Zero-based index of the character.</param>
        /// <param name="buffer">A buffer receiving the font name.</param>
        /// <param name="buflen">The length of |buffer| in bytes.</param>
        /// <param name="flags">
        /// Optional pointer to an int receiving the font flags.
        /// These flags should be interpreted per PDF spec 1.7
        /// Section 5.7.1 Font Descriptor Flags.
        /// </param>
        /// <returns>
        /// On success, return the length of the font name, including the
        /// trailing NUL character, in bytes. If this length is less than or
        /// equal to |length|, |buffer| is set to the font name, |flags| is
        /// set to the font flags. |buffer| is in UTF-8 encoding. Return 0 on
        /// failure.
        /// </returns>
        public static uint FPDFText_GetFontInfo(global::PdfLibCore.Generated.FPDF_Textpage text_page, int index, __IntPtr buffer, uint buflen, ref int flags)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            fixed (int* __flags4 = &flags)
            {
                var __arg4 = __flags4;
                var ___ret = __Internal.FPDFText_GetFontInfo(__arg0, index, buffer, buflen, __arg4);
                return ___ret;
            }
        }

        /// <summary>Get the font weight of a particular character.</summary>
        /// <param name="text_page">Handle to a text page information structure. Returned by FPDFText_LoadPage function.</param>
        /// <param name="index">Zero-based index of the character.</param>
        /// <returns>
        /// On success, return the font weight of the particular character. If
        /// |text_page| is invalid, if |index| is out of bounds, or if the
        /// character's text object is undefined, return -1.
        /// </returns>
        public static int FPDFText_GetFontWeight(global::PdfLibCore.Generated.FPDF_Textpage text_page, int index)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            var ___ret = __Internal.FPDFText_GetFontWeight(__arg0, index);
            return ___ret;
        }

        /// <summary>Get text rendering mode of character.</summary>
        /// <param name="text_page">Handle to a text page information structure. Returned by FPDFText_LoadPage function.</param>
        /// <param name="index">Zero-based index of the character.</param>
        /// <returns>
        /// On success, return the render mode value. A valid value is of type
        /// FPDF_TEXT_RENDERMODE. If |text_page| is invalid, if |index| is out
        /// of bounds, or if the text object is undefined, then return
        /// FPDF_TEXTRENDERMODE_UNKNOWN.
        /// </returns>
        public static global::PdfLibCore.Generated.FPDF_TEXT_RENDERMODE FPDFText_GetTextRenderMode(global::PdfLibCore.Generated.FPDF_Textpage text_page, int index)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            var ___ret = __Internal.FPDFText_GetTextRenderMode(__arg0, index);
            return ___ret;
        }

        /// <summary>Get the fill color of a particular character.</summary>
        /// <param name="text_page">Handle to a text page information structure. Returned by FPDFText_LoadPage function.</param>
        /// <param name="index">Zero-based index of the character.</param>
        /// <param name="R">Pointer to an unsigned int number receiving the red value of the fill color.</param>
        /// <param name="G">Pointer to an unsigned int number receiving the green value of the fill color.</param>
        /// <param name="B">Pointer to an unsigned int number receiving the blue value of the fill color.</param>
        /// <param name="A">Pointer to an unsigned int number receiving the alpha value of the fill color.</param>
        /// <returns>Whether the call succeeded. If false, |R|, |G|, |B| and |A| are unchanged.</returns>
        public static global::PdfLibCore.Types.FPDF_BOOL FPDFText_GetFillColor(global::PdfLibCore.Generated.FPDF_Textpage text_page, int index, ref uint R, ref uint G, ref uint B, ref uint A)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            fixed (uint* __R2 = &R)
            {
                var __arg2 = __R2;
                fixed (uint* __G3 = &G)
                {
                    var __arg3 = __G3;
                    fixed (uint* __B4 = &B)
                    {
                        var __arg4 = __B4;
                        fixed (uint* __A5 = &A)
                        {
                            var __arg5 = __A5;
                            var ___ret = __Internal.FPDFText_GetFillColor(__arg0, index, __arg2, __arg3, __arg4, __arg5);
                            return ___ret;
                        }
                    }
                }
            }
        }

        /// <summary>Get the stroke color of a particular character.</summary>
        /// <param name="text_page">Handle to a text page information structure. Returned by FPDFText_LoadPage function.</param>
        /// <param name="index">Zero-based index of the character.</param>
        /// <param name="R">Pointer to an unsigned int number receiving the red value of the stroke color.</param>
        /// <param name="G">Pointer to an unsigned int number receiving the green value of the stroke color.</param>
        /// <param name="B">Pointer to an unsigned int number receiving the blue value of the stroke color.</param>
        /// <param name="A">Pointer to an unsigned int number receiving the alpha value of the stroke color.</param>
        /// <returns>Whether the call succeeded. If false, |R|, |G|, |B| and |A| are unchanged.</returns>
        public static global::PdfLibCore.Types.FPDF_BOOL FPDFText_GetStrokeColor(global::PdfLibCore.Generated.FPDF_Textpage text_page, int index, ref uint R, ref uint G, ref uint B, ref uint A)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            fixed (uint* __R2 = &R)
            {
                var __arg2 = __R2;
                fixed (uint* __G3 = &G)
                {
                    var __arg3 = __G3;
                    fixed (uint* __B4 = &B)
                    {
                        var __arg4 = __B4;
                        fixed (uint* __A5 = &A)
                        {
                            var __arg5 = __A5;
                            var ___ret = __Internal.FPDFText_GetStrokeColor(__arg0, index, __arg2, __arg3, __arg4, __arg5);
                            return ___ret;
                        }
                    }
                }
            }
        }

        /// <summary>Get character rotation angle.</summary>
        /// <param name="text_page">Handle to a text page information structure. Returned by FPDFText_LoadPage function.</param>
        /// <param name="index">Zero-based index of the character.</param>
        /// <returns>
        /// On success, return the angle value in radian. Value will always be
        /// greater or equal to 0. If |text_page| is invalid, or if |index| is
        /// out of bounds, then return -1.
        /// </returns>
        public static float FPDFText_GetCharAngle(global::PdfLibCore.Generated.FPDF_Textpage text_page, int index)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            var ___ret = __Internal.FPDFText_GetCharAngle(__arg0, index);
            return ___ret;
        }

        /// <summary>Get bounding box of a particular character.</summary>
        /// <param name="text_page">Handle to a text page information structure. Returned by FPDFText_LoadPage function.</param>
        /// <param name="index">Zero-based index of the character.</param>
        /// <param name="left">Pointer to a double number receiving left position of the character box.</param>
        /// <param name="right">Pointer to a double number receiving right position of the character box.</param>
        /// <param name="bottom">Pointer to a double number receiving bottom position of the character box.</param>
        /// <param name="top">Pointer to a double number receiving top position of the character box.</param>
        /// <remarks>All positions are measured in PDF &quot;user space&quot;.</remarks>
        /// <returns>
        /// On success, return TRUE and fill in |left|, |right|, |bottom|, and
        /// |top|. If |text_page| is invalid, or if |index| is out of bounds,
        /// then return FALSE, and the out parameters remain unmodified.
        /// </returns>
        public static global::PdfLibCore.Types.FPDF_BOOL FPDFText_GetCharBox(global::PdfLibCore.Generated.FPDF_Textpage text_page, int index, ref double left, ref double right, ref double bottom, ref double top)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            fixed (double* __left2 = &left)
            {
                var __arg2 = __left2;
                fixed (double* __right3 = &right)
                {
                    var __arg3 = __right3;
                    fixed (double* __bottom4 = &bottom)
                    {
                        var __arg4 = __bottom4;
                        fixed (double* __top5 = &top)
                        {
                            var __arg5 = __top5;
                            var ___ret = __Internal.FPDFText_GetCharBox(__arg0, index, __arg2, __arg3, __arg4, __arg5);
                            return ___ret;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Get a &quot;loose&quot; bounding box of a particular character, i.e., covering
        /// the entire glyph bounds, without taking the actual glyph shape into
        /// account.
        /// </summary>
        /// <param name="text_page">Handle to a text page information structure. Returned by FPDFText_LoadPage function.</param>
        /// <param name="index">Zero-based index of the character.</param>
        /// <param name="rect">Pointer to a FS_RECTF receiving the character box.</param>
        /// <remarks>All positions are measured in PDF &quot;user space&quot;.</remarks>
        /// <returns>
        /// On success, return TRUE and fill in |rect|. If |text_page| is
        /// invalid, or if |index| is out of bounds, then return FALSE, and the
        /// |rect| out parameter remains unmodified.
        /// </returns>
        public static global::PdfLibCore.Types.FPDF_BOOL FPDFText_GetLooseCharBox(global::PdfLibCore.Generated.FPDF_Textpage text_page, int index, global::PdfLibCore.Generated.FS_RECTF_ rect)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            var __arg2 = rect is null ? __IntPtr.Zero : rect.__Instance;
            var ___ret = __Internal.FPDFText_GetLooseCharBox(__arg0, index, __arg2);
            return ___ret;
        }

        /// <summary>Get the effective transformation matrix for a particular character.</summary>
        /// <param name="text_page">Handle to a text page information structure. Returned by FPDFText_LoadPage().</param>
        /// <param name="index">Zero-based index of the character.</param>
        /// <param name="matrix">Pointer to a FS_MATRIX receiving the transformation matrix.</param>
        /// <returns>
        /// On success, return TRUE and fill in |matrix|. If |text_page| is
        /// invalid, or if |index| is out of bounds, or if |matrix| is NULL,
        /// then return FALSE, and |matrix| remains unmodified.
        /// </returns>
        public static global::PdfLibCore.Types.FPDF_BOOL FPDFText_GetMatrix(global::PdfLibCore.Generated.FPDF_Textpage text_page, int index, global::PdfLibCore.Generated.FS_MATRIX_ matrix)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            var __arg2 = matrix is null ? __IntPtr.Zero : matrix.__Instance;
            var ___ret = __Internal.FPDFText_GetMatrix(__arg0, index, __arg2);
            return ___ret;
        }

        /// <summary>Get origin of a particular character.</summary>
        /// <param name="text_page">Handle to a text page information structure. Returned by FPDFText_LoadPage function.</param>
        /// <param name="index">Zero-based index of the character.</param>
        /// <param name="x">Pointer to a double number receiving x coordinate of the character origin.</param>
        /// <param name="y">Pointer to a double number receiving y coordinate of the character origin.</param>
        /// <remarks>All positions are measured in PDF &quot;user space&quot;.</remarks>
        /// <returns>Whether the call succeeded. If false, x and y are unchanged.</returns>
        public static global::PdfLibCore.Types.FPDF_BOOL FPDFText_GetCharOrigin(global::PdfLibCore.Generated.FPDF_Textpage text_page, int index, ref double x, ref double y)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            fixed (double* __x2 = &x)
            {
                var __arg2 = __x2;
                fixed (double* __y3 = &y)
                {
                    var __arg3 = __y3;
                    var ___ret = __Internal.FPDFText_GetCharOrigin(__arg0, index, __arg2, __arg3);
                    return ___ret;
                }
            }
        }

        /// <summary>Get the index of a character at or nearby a certain position on the page.</summary>
        /// <param name="text_page">Handle to a text page information structure. Returned by FPDFText_LoadPage function.</param>
        /// <param name="x">X position in PDF &quot;user space&quot;.</param>
        /// <param name="y">Y position in PDF &quot;user space&quot;.</param>
        /// <param name="xTolerance">An x-axis tolerance value for character hit detection, in point units.</param>
        /// <param name="yTolerance">A y-axis tolerance value for character hit detection, in point units.</param>
        /// <returns>
        /// The zero-based index of the character at, or nearby the point (x,y).
        /// If there is no character at or nearby the point, return value will
        /// be -1. If an error occurs, -3 will be returned.
        /// </returns>
        public static int FPDFText_GetCharIndexAtPos(global::PdfLibCore.Generated.FPDF_Textpage text_page, double x, double y, double xTolerance, double yTolerance)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            var ___ret = __Internal.FPDFText_GetCharIndexAtPos(__arg0, x, y, xTolerance, yTolerance);
            return ___ret;
        }

        /// <summary>Extract unicode text string from the page.</summary>
        /// <param name="text_page">Handle to a text page information structure. Returned by FPDFText_LoadPage function.</param>
        /// <param name="start_index">Index for the start characters.</param>
        /// <param name="count">Number of characters to be extracted.</param>
        /// <param name="result">
        /// A buffer (allocated by application) receiving the
        /// extracted unicodes. The size of the buffer must be
        /// able to hold the number of characters plus a
        /// terminator.
        /// </param>
        /// <remarks>
        /// This function ignores characters without unicode information.
        /// It returns all characters on the page, even those that are not
        /// visible when the page has a cropbox. To filter out the characters
        /// outside of the cropbox, use FPDF_GetPageBoundingBox() and
        /// FPDFText_GetCharBox().
        /// </remarks>
        /// <returns>Number of characters written into the result buffer, including the trailing terminator.</returns>
        public static int FPDFText_GetText(global::PdfLibCore.Generated.FPDF_Textpage text_page, int start_index, int count, ref ushort result)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            fixed (ushort* __result3 = &result)
            {
                var __arg3 = __result3;
                var ___ret = __Internal.FPDFText_GetText(__arg0, start_index, count, __arg3);
                return ___ret;
            }
        }

        /// <summary>
        /// Counts number of rectangular areas occupied by a segment of text,
        /// and caches the result for subsequent FPDFText_GetRect() calls.
        /// </summary>
        /// <param name="text_page">Handle to a text page information structure. Returned by FPDFText_LoadPage function.</param>
        /// <param name="start_index">Index for the start character.</param>
        /// <param name="count">Number of characters, or -1 for all remaining.</param>
        /// <remarks>
        /// This function, along with FPDFText_GetRect can be used by
        /// applications to detect the position on the page for a text segment,
        /// so proper areas can be highlighted. The FPDFText_* functions will
        /// automatically merge small character boxes into bigger one if those
        /// characters are on the same line and use same font settings.
        /// </remarks>
        /// <returns>Number of rectangles, 0 if text_page is null, or -1 on bad start_index.</returns>
        public static int FPDFText_CountRects(global::PdfLibCore.Generated.FPDF_Textpage text_page, int start_index, int count)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            var ___ret = __Internal.FPDFText_CountRects(__arg0, start_index, count);
            return ___ret;
        }

        /// <summary>Get a rectangular area from the result generated by FPDFText_CountRects.</summary>
        /// <param name="text_page">Handle to a text page information structure. Returned by FPDFText_LoadPage function.</param>
        /// <param name="rect_index">Zero-based index for the rectangle.</param>
        /// <param name="left">Pointer to a double value receiving the rectangle left boundary.</param>
        /// <param name="top">Pointer to a double value receiving the rectangle top boundary.</param>
        /// <param name="right">Pointer to a double value receiving the rectangle right boundary.</param>
        /// <param name="bottom">Pointer to a double value receiving the rectangle bottom boundary.</param>
        /// <returns>
        /// On success, return TRUE and fill in |left|, |top|, |right|, and
        /// |bottom|. If |text_page| is invalid then return FALSE, and the out
        /// parameters remain unmodified. If |text_page| is valid but
        /// |rect_index| is out of bounds, then return FALSE and set the out
        /// parameters to 0.
        /// </returns>
        public static global::PdfLibCore.Types.FPDF_BOOL FPDFText_GetRect(global::PdfLibCore.Generated.FPDF_Textpage text_page, int rect_index, ref double left, ref double top, ref double right, ref double bottom)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            fixed (double* __left2 = &left)
            {
                var __arg2 = __left2;
                fixed (double* __top3 = &top)
                {
                    var __arg3 = __top3;
                    fixed (double* __right4 = &right)
                    {
                        var __arg4 = __right4;
                        fixed (double* __bottom5 = &bottom)
                        {
                            var __arg5 = __bottom5;
                            var ___ret = __Internal.FPDFText_GetRect(__arg0, rect_index, __arg2, __arg3, __arg4, __arg5);
                            return ___ret;
                        }
                    }
                }
            }
        }

        /// <summary>Extract unicode text within a rectangular boundary on the page.</summary>
        /// <param name="text_page">Handle to a text page information structure. Returned by FPDFText_LoadPage function.</param>
        /// <param name="left">Left boundary.</param>
        /// <param name="top">Top boundary.</param>
        /// <param name="right">Right boundary.</param>
        /// <param name="bottom">Bottom boundary.</param>
        /// <param name="buffer">A unicode buffer.</param>
        /// <param name="buflen">Number of characters (not bytes) for the buffer, excluding an additional terminator.</param>
        /// <returns>
        /// If buffer is NULL or buflen is zero, return number of characters
        /// (not bytes) of text present within the rectangle, excluding a
        /// terminating NUL. Generally you should pass a buffer at least one
        /// larger than this if you want a terminating NUL, which will be
        /// provided if space is available. Otherwise, return number of
        /// characters copied into the buffer, including the terminating NUL
        /// when space for it is available.
        /// Comment:
        /// If the buffer is too small, as much text as will fit is copied into
        /// it.
        /// </returns>
        public static int FPDFText_GetBoundedText(global::PdfLibCore.Generated.FPDF_Textpage text_page, double left, double top, double right, double bottom, ref ushort buffer, int buflen)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            fixed (ushort* __buffer5 = &buffer)
            {
                var __arg5 = __buffer5;
                var ___ret = __Internal.FPDFText_GetBoundedText(__arg0, left, top, right, bottom, __arg5, buflen);
                return ___ret;
            }
        }

        /// <summary>Start a search.</summary>
        /// <param name="text_page">Handle to a text page information structure. Returned by FPDFText_LoadPage function.</param>
        /// <param name="findwhat">A unicode match pattern.</param>
        /// <param name="flags">Option flags.</param>
        /// <param name="start_index">Start from this character. -1 for end of the page.</param>
        /// <returns>A handle for the search context. FPDFText_FindClose must be called to release this handle.</returns>
        public static global::PdfLibCore.Generated.FPDF_Schhandle FPDFText_FindStart(global::PdfLibCore.Generated.FPDF_Textpage text_page, ref string findwhat, uint flags, int start_index)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            var ___ret = __Internal.FPDFText_FindStart(__arg0, findwhat, flags, start_index);
            var __result0 = global::PdfLibCore.Generated.FPDF_Schhandle.__CreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Search in the direction from page start to end.</summary>
        /// <param name="handle">A search context handle returned by FPDFText_FindStart.</param>
        /// <returns>Whether a match is found.</returns>
        public static global::PdfLibCore.Types.FPDF_BOOL FPDFText_FindNext(global::PdfLibCore.Generated.FPDF_Schhandle handle)
        {
            var __arg0 = handle is null ? __IntPtr.Zero : handle.__Instance;
            var ___ret = __Internal.FPDFText_FindNext(__arg0);
            return ___ret;
        }

        /// <summary>Search in the direction from page end to start.</summary>
        /// <param name="handle">A search context handle returned by FPDFText_FindStart.</param>
        /// <returns>Whether a match is found.</returns>
        public static global::PdfLibCore.Types.FPDF_BOOL FPDFText_FindPrev(global::PdfLibCore.Generated.FPDF_Schhandle handle)
        {
            var __arg0 = handle is null ? __IntPtr.Zero : handle.__Instance;
            var ___ret = __Internal.FPDFText_FindPrev(__arg0);
            return ___ret;
        }

        /// <summary>Get the starting character index of the search result.</summary>
        /// <param name="handle">A search context handle returned by FPDFText_FindStart.</param>
        /// <returns>Index for the starting character.</returns>
        public static int FPDFText_GetSchResultIndex(global::PdfLibCore.Generated.FPDF_Schhandle handle)
        {
            var __arg0 = handle is null ? __IntPtr.Zero : handle.__Instance;
            var ___ret = __Internal.FPDFText_GetSchResultIndex(__arg0);
            return ___ret;
        }

        /// <summary>Get the number of matched characters in the search result.</summary>
        /// <param name="handle">A search context handle returned by FPDFText_FindStart.</param>
        /// <returns>Number of matched characters.</returns>
        public static int FPDFText_GetSchCount(global::PdfLibCore.Generated.FPDF_Schhandle handle)
        {
            var __arg0 = handle is null ? __IntPtr.Zero : handle.__Instance;
            var ___ret = __Internal.FPDFText_GetSchCount(__arg0);
            return ___ret;
        }

        /// <summary>Release a search context.</summary>
        /// <param name="handle">A search context handle returned by FPDFText_FindStart.</param>
        public static void FPDFText_FindClose(global::PdfLibCore.Generated.FPDF_Schhandle handle)
        {
            var __arg0 = handle is null ? __IntPtr.Zero : handle.__Instance;
            __Internal.FPDFText_FindClose(__arg0);
        }

        /// <summary>Prepare information about weblinks in a page.</summary>
        /// <param name="text_page">Handle to a text page information structure. Returned by FPDFText_LoadPage function.</param>
        /// <remarks>
        /// Weblinks are those links implicitly embedded in PDF pages. PDF also
        /// has a type of annotation called &quot;link&quot; (FPDFTEXT doesn't deal with
        /// that kind of link). FPDFTEXT weblink feature is useful for
        /// automatically detecting links in the page contents. For example,
        /// things like &quot;https://www.example.com&quot; will be detected, so
        /// applications can allow user to click on those characters to activate
        /// the link, even the PDF doesn't come with link annotations.
        /// FPDFLink_CloseWebLinks must be called to release resources.
        /// </remarks>
        /// <returns>A handle to the page's links information structure, or NULL if something goes wrong.</returns>
        public static global::PdfLibCore.Generated.FPDF_Pagelink FPDFLink_LoadWebLinks(global::PdfLibCore.Generated.FPDF_Textpage text_page)
        {
            var __arg0 = text_page is null ? __IntPtr.Zero : text_page.__Instance;
            var ___ret = __Internal.FPDFLink_LoadWebLinks(__arg0);
            var __result0 = global::PdfLibCore.Generated.FPDF_Pagelink.__CreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Count number of detected web links.</summary>
        /// <param name="link_page">Handle returned by FPDFLink_LoadWebLinks.</param>
        /// <returns>Number of detected web links.</returns>
        public static int FPDFLink_CountWebLinks(global::PdfLibCore.Generated.FPDF_Pagelink link_page)
        {
            var __arg0 = link_page is null ? __IntPtr.Zero : link_page.__Instance;
            var ___ret = __Internal.FPDFLink_CountWebLinks(__arg0);
            return ___ret;
        }

        /// <summary>Fetch the URL information for a detected web link.</summary>
        /// <param name="link_page">Handle returned by FPDFLink_LoadWebLinks.</param>
        /// <param name="link_index">Zero-based index for the link.</param>
        /// <param name="buffer">A unicode buffer for the result.</param>
        /// <param name="buflen">Number of 16-bit code units (not bytes) for the buffer, including an additional terminator.</param>
        /// <returns>
        /// If |buffer| is NULL or |buflen| is zero, return the number of 16-bit
        /// code units (not bytes) needed to buffer the result (an additional
        /// terminator is included in this count).
        /// Otherwise, copy the result into |buffer|, truncating at |buflen| if
        /// the result is too large to fit, and return the number of 16-bit code
        /// units actually copied into the buffer (the additional terminator is
        /// also included in this count).
        /// If |link_index| does not correspond to a valid link, then the result
        /// is an empty string.
        /// </returns>
        public static int FPDFLink_GetURL(global::PdfLibCore.Generated.FPDF_Pagelink link_page, int link_index, ref ushort buffer, int buflen)
        {
            var __arg0 = link_page is null ? __IntPtr.Zero : link_page.__Instance;
            fixed (ushort* __buffer2 = &buffer)
            {
                var __arg2 = __buffer2;
                var ___ret = __Internal.FPDFLink_GetURL(__arg0, link_index, __arg2, buflen);
                return ___ret;
            }
        }

        /// <summary>Count number of rectangular areas for the link.</summary>
        /// <param name="link_page">Handle returned by FPDFLink_LoadWebLinks.</param>
        /// <param name="link_index">Zero-based index for the link.</param>
        /// <returns>
        /// Number of rectangular areas for the link.  If |link_index| does
        /// not correspond to a valid link, then 0 is returned.
        /// </returns>
        public static int FPDFLink_CountRects(global::PdfLibCore.Generated.FPDF_Pagelink link_page, int link_index)
        {
            var __arg0 = link_page is null ? __IntPtr.Zero : link_page.__Instance;
            var ___ret = __Internal.FPDFLink_CountRects(__arg0, link_index);
            return ___ret;
        }

        /// <summary>Fetch the boundaries of a rectangle for a link.</summary>
        /// <param name="link_page">Handle returned by FPDFLink_LoadWebLinks.</param>
        /// <param name="link_index">Zero-based index for the link.</param>
        /// <param name="rect_index">Zero-based index for a rectangle.</param>
        /// <param name="left">Pointer to a double value receiving the rectangle left boundary.</param>
        /// <param name="top">Pointer to a double value receiving the rectangle top boundary.</param>
        /// <param name="right">Pointer to a double value receiving the rectangle right boundary.</param>
        /// <param name="bottom">Pointer to a double value receiving the rectangle bottom boundary.</param>
        /// <returns>
        /// On success, return TRUE and fill in |left|, |top|, |right|, and
        /// |bottom|. If |link_page| is invalid or if |link_index| does not
        /// correspond to a valid link, then return FALSE, and the out
        /// parameters remain unmodified.
        /// </returns>
        public static global::PdfLibCore.Types.FPDF_BOOL FPDFLink_GetRect(global::PdfLibCore.Generated.FPDF_Pagelink link_page, int link_index, int rect_index, ref double left, ref double top, ref double right, ref double bottom)
        {
            var __arg0 = link_page is null ? __IntPtr.Zero : link_page.__Instance;
            fixed (double* __left3 = &left)
            {
                var __arg3 = __left3;
                fixed (double* __top4 = &top)
                {
                    var __arg4 = __top4;
                    fixed (double* __right5 = &right)
                    {
                        var __arg5 = __right5;
                        fixed (double* __bottom6 = &bottom)
                        {
                            var __arg6 = __bottom6;
                            var ___ret = __Internal.FPDFLink_GetRect(__arg0, link_index, rect_index, __arg3, __arg4, __arg5, __arg6);
                            return ___ret;
                        }
                    }
                }
            }
        }

        /// <summary>Fetch the start char index and char count for a link.</summary>
        /// <param name="link_page">Handle returned by FPDFLink_LoadWebLinks.</param>
        /// <param name="link_index">Zero-based index for the link.</param>
        /// <param name="start_char_index">pointer to int receiving the start char index</param>
        /// <param name="char_count">pointer to int receiving the char count</param>
        /// <returns>
        /// On success, return TRUE and fill in |start_char_index| and
        /// |char_count|. if |link_page| is invalid or if |link_index| does
        /// not correspond to a valid link, then return FALSE and the out
        /// parameters remain unmodified.
        /// </returns>
        public static global::PdfLibCore.Types.FPDF_BOOL FPDFLink_GetTextRange(global::PdfLibCore.Generated.FPDF_Pagelink link_page, int link_index, ref int start_char_index, ref int char_count)
        {
            var __arg0 = link_page is null ? __IntPtr.Zero : link_page.__Instance;
            fixed (int* __start_char_index2 = &start_char_index)
            {
                var __arg2 = __start_char_index2;
                fixed (int* __char_count3 = &char_count)
                {
                    var __arg3 = __char_count3;
                    var ___ret = __Internal.FPDFLink_GetTextRange(__arg0, link_index, __arg2, __arg3);
                    return ___ret;
                }
            }
        }

        /// <summary>Release resources used by weblink feature.</summary>
        /// <param name="link_page">Handle returned by FPDFLink_LoadWebLinks.</param>
        public static void FPDFLink_CloseWebLinks(global::PdfLibCore.Generated.FPDF_Pagelink link_page)
        {
            var __arg0 = link_page is null ? __IntPtr.Zero : link_page.__Instance;
            __Internal.FPDFLink_CloseWebLinks(__arg0);
        }
    }
}
