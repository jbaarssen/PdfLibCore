// Built from precompiled binaries at https://github.com/bblanchon/pdfium-binaries/releases/tag/chromium/5772
// Github release api https://api.github.com/repos/bblanchon/pdfium-binaries/releases/102934879
// PDFium version v115.0.5772.0 chromium/5772 [master]
// Built on: Wed, 17 May 2023 13:34:04 GMT

// ReSharper disable all
#pragma warning disable CS8500 // This takes the address of, gets the size of, or declares a pointer to a managed type

// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace PdfLibCore.Generated
{
    public unsafe partial class FPDF_FILEWRITE_ : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal int version;
            internal __IntPtr WriteBlock;

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "??0FPDF_FILEWRITE_@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        protected bool __ownsNativeInstance;

        internal static FPDF_FILEWRITE_ __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FPDF_FILEWRITE_(native.ToPointer(), skipVTables);
        }

        internal static FPDF_FILEWRITE_ __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPDF_FILEWRITE_(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPDF_FILEWRITE_(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
        }

        protected FPDF_FILEWRITE_(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FPDF_FILEWRITE_()
        {
            if (GetType().FullName != "PdfLibCore.Generated.FPDF_FILEWRITE_")
                throw new Exception("PdfLibCore.Generated.FPDF_FILEWRITE_: Can't inherit from classes with disabled NativeToManaged map");
            __Instance = Marshal.AllocHGlobal(sizeof(global::PdfLibCore.Generated.FPDF_FILEWRITE_.__Internal));
            __ownsNativeInstance = true;
        }

        public FPDF_FILEWRITE_(global::PdfLibCore.Generated.FPDF_FILEWRITE_ _0)
        {
            if (GetType().FullName != "PdfLibCore.Generated.FPDF_FILEWRITE_")
                throw new Exception("PdfLibCore.Generated.FPDF_FILEWRITE_: Can't inherit from classes with disabled NativeToManaged map");
            __Instance = Marshal.AllocHGlobal(sizeof(global::PdfLibCore.Generated.FPDF_FILEWRITE_.__Internal));
            __ownsNativeInstance = true;
            *((global::PdfLibCore.Generated.FPDF_FILEWRITE_.__Internal*) __Instance) = *((global::PdfLibCore.Generated.FPDF_FILEWRITE_.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Version
        {
            get
            {
                return ((__Internal*)__Instance)->version;
            }

            set
            {
                ((__Internal*)__Instance)->version = value;
            }
        }

        public global::PdfLibCore.Generated.Delegates.Func_int___IntPtr___IntPtr_uint WriteBlock
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->WriteBlock;
                return __ptr0 == IntPtr.Zero? null : (global::PdfLibCore.Generated.Delegates.Func_int___IntPtr___IntPtr_uint) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::PdfLibCore.Generated.Delegates.Func_int___IntPtr___IntPtr_uint));
            }

            set
            {
                ((__Internal*)__Instance)->WriteBlock = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public static unsafe partial class Pdfium
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_SaveAsCopy", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::PdfLibCore.Types.FPDF_BOOL FPDF_SaveAsCopy(__IntPtr document, __IntPtr pFileWrite, long flags);

            [SuppressUnmanagedCodeSecurity, DllImport("Pdfium", EntryPoint = "FPDF_SaveWithVersion", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::PdfLibCore.Types.FPDF_BOOL FPDF_SaveWithVersion(__IntPtr document, __IntPtr pFileWrite, long flags, int fileVersion);
        }

        /// <summary>Saves the copy of specified document in custom way.</summary>
        /// <param name="document">Handle to document, as returned by FPDF_LoadDocument() or FPDF_CreateNewDocument().</param>
        /// <param name="pFileWrite">A pointer to a custom file write structure.</param>
        /// <param name="flags">The creating flags.</param>
        /// <returns>TRUE for succeed, FALSE for failed.</returns>
        public static global::PdfLibCore.Types.FPDF_BOOL FPDF_SaveAsCopy(global::PdfLibCore.Generated.FPDF_Document document, global::PdfLibCore.Generated.FPDF_FILEWRITE_ pFileWrite, long flags)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __arg1 = pFileWrite is null ? __IntPtr.Zero : pFileWrite.__Instance;
            var ___ret = __Internal.FPDF_SaveAsCopy(__arg0, __arg1, flags);
            return ___ret;
        }

        /// <summary>
        /// Same as FPDF_SaveAsCopy(), except the file version of the
        /// saved document can be specified by the caller.
        /// </summary>
        /// <param name="document">Handle to document.</param>
        /// <param name="pFileWrite">A pointer to a custom file write structure.</param>
        /// <param name="flags">The creating flags.</param>
        /// <param name="fileVersion">The PDF file version. File version: 14 for 1.4, 15 for 1.5, ...</param>
        /// <returns>TRUE if succeed, FALSE if failed.</returns>
        public static global::PdfLibCore.Types.FPDF_BOOL FPDF_SaveWithVersion(global::PdfLibCore.Generated.FPDF_Document document, global::PdfLibCore.Generated.FPDF_FILEWRITE_ pFileWrite, long flags, int fileVersion)
        {
            var __arg0 = document is null ? __IntPtr.Zero : document.__Instance;
            var __arg1 = pFileWrite is null ? __IntPtr.Zero : pFileWrite.__Instance;
            var ___ret = __Internal.FPDF_SaveWithVersion(__arg0, __arg1, flags, fileVersion);
            return ___ret;
        }
    }
}
