<#@ template language="C#" hostspecific="true"#>
<#@ output extension=".cs" #>
<# // ------------------------------------------------------ Code Start ------------------------------------------------------
//This types from here: https://pdfium.googlesource.com/pdfium/+/master/public/fpdfview.h from line: // PDF types - use incomplete types (never completed) just for API type safety.
    string[] names =
    {
        "FPDF_ACTION",
        "FPDF_ANNOTATION",
        "FPDF_ATTACHMENT",
        "FPDF_BITMAP",
        "FPDF_BOOKMARK",
        "FPDF_CLIPPATH",
        "FPDF_DEST",
        "FPDF_DOCUMENT",
        "FPDF_FONT",
        "FPDF_FORMHANDLE",
        "FPDF_JAVASCRIPT_ACTION",
        "FPDF_LINK",
        "FPDF_PAGE",
        "FPDF_PAGELINK",
        "FPDF_PAGEOBJECT", // Page object(text, path, etc)
        "FPDF_PAGEOBJECTMARK",
        "FPDF_PAGERANGE",
        "FPDF_PATHSEGMENT",
        "FPDF_RECORDER",
        "FPDF_SCHHANDLE",
        "FPDF_STRUCTELEMENT",
        "FPDF_STRUCTTREE",
        "FPDF_TEXTPAGE",
        "FPDF_WIDGET"
    };
// --------------------------------------------------------- Code End ----------------------------------------------------- #>
/*
This file is part of PdfCoreLib, a wrapper around the PDFium library for the .NET.
Inspired by the awesome work of PDFiumSharp by Tobias Meyer.

Copyright (C) 2021 Jan Baarsssen
License: Microsoft Reciprocal License (MS-RL)
*/

// AUTOGENERATED FILE
// DO NOT MODIFY
using System;
using System.Runtime.InteropServices;
using System.Threading;

namespace PdfLibCore.Types
{
<# // ------------------------------------------------------ Code Start ------------------------------------------------------
    foreach (var name in names)
    {
        // --------------------------------------------------------- Code End ----------------------------------------------------- #>

	/// <summary>Handle to a <#= name #></summary>
	[StructLayout(LayoutKind.Sequential)]
    public struct <#= name #> : IHandle<<#= name #>>
	{
		private IntPtr _pointer;

		/// <summary>Gets a value indicating whether the handle is <c>null</c>.</summary>
		public bool IsNull => _pointer == IntPtr.Zero;

		/// <summary>Gets a handle representing <c>null</c>.</summary>
		public static <#= name #> Null => new <#= name #>();

		private <#= name #>(IntPtr ptr) => _pointer = ptr;

		<#= name #> IHandle<<#= name #>>.SetToNull() => new <#= name #>(Interlocked.Exchange(ref _pointer, IntPtr.Zero));

        public override string ToString() => $"<#= name #>: 0x{_pointer.ToString("X16")}";
    }
<# // ------------------------------------------------------ Code Start ------------------------------------------------------
    }
// --------------------------------------------------------- Code End ----------------------------------------------------- #>
}
