using System.Runtime.InteropServices;
using System.Security;

/*
This file is part of PdfLibCore, a wrapper around the PDFium library for the .NET.
Inspired by the awesome work of PDFiumSharp by Tobias Meyer.

Copyright (C) 2023 J.C.A. Kokenberg & Jan Baarssen
License: Microsoft Reciprocal License (MS-RL)
*/
// AUTOGENERATED FILE - 04-05-2023 (02:14:02) - Utc
// DO NOT MODIFY
namespace PdfLibCore;
internal static class PlatformInvoke
{
    private const string DllName = "pdfium";
    ///<summary>Initialize the FPDFSDK library</summary>
    ///<remarks>
    /// Convenience function to call FPDF_InitLibraryWithConfig() for
    /// backwards compatibility purposes. This will be deprecated in the
    /// future.
    ///</remarks>
    [DllImport(DllName, EntryPoint = nameof(FPDF_InitLibrary), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_InitLibrary();
    ///<summary>Initialize the FPDFSDK library</summary>
    ///<param name = "config">configuration information as above.</param>
    ///<remarks>
    /// You have to call this function before you can call any PDF
    /// processing functions.
    ///</remarks>
    [DllImport(DllName, EntryPoint = nameof(FPDF_InitLibraryWithConfig), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_InitLibraryWithConfig(const FPDF_LIBRARY_CONFIG* config);
    ///<summary>Release all resources allocated by the FPDFSDK library.</summary>
    ///<remarks>
    /// You can call this function to release all memory blocks allocated by
    /// the library.
    /// After this function is called, you should not call any PDF
    /// processing functions.
    ///</remarks>
    [DllImport(DllName, EntryPoint = nameof(FPDF_DestroyLibrary), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_DestroyLibrary();
    ///<summary>Set the policy for the sandbox environment.</summary>
    ///<param name = "policy">
    /// The specified policy for setting, for example:
    /// FPDF_POLICY_MACHINETIME_ACCESS.
    ///</param>
    ///<param name = "enable">True to enable, false to disable the policy.</param>
    [DllImport(DllName, EntryPoint = nameof(FPDF_SetSandBoxPolicy), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_SetSandBoxPolicy(typedef unsigned int FPDF_DWORD policy, typedef int FPDF_BOOL enable);
    ///<summary>Set printing mode when printing on Windows.</summary>
    ///<param name = "mode">
    /// FPDF_PRINTMODE_EMF to output EMF (default)
    /// FPDF_PRINTMODE_TEXTONLY to output text only (for charstream
    /// devices)
    /// FPDF_PRINTMODE_POSTSCRIPT2 to output level 2 PostScript into
    /// EMF as a series of GDI comments.
    /// FPDF_PRINTMODE_POSTSCRIPT3 to output level 3 PostScript into
    /// EMF as a series of GDI comments.
    /// FPDF_PRINTMODE_POSTSCRIPT2_PASSTHROUGH to output level 2
    /// PostScript via ExtEscape() in PASSTHROUGH mode.
    /// FPDF_PRINTMODE_POSTSCRIPT3_PASSTHROUGH to output level 3
    /// PostScript via ExtEscape() in PASSTHROUGH mode.
    /// FPDF_PRINTMODE_EMF_IMAGE_MASKS to output EMF, with more
    /// efficient processing of documents containing image masks.
    /// FPDF_PRINTMODE_POSTSCRIPT3_TYPE42 to output level 3
    /// PostScript with embedded Type 42 fonts, when applicable, into
    /// EMF as a series of GDI comments.
    /// FPDF_PRINTMODE_POSTSCRIPT3_TYPE42_PASSTHROUGH to output level
    /// 3 PostScript with embedded Type 42 fonts, when applicable,
    /// via ExtEscape() in PASSTHROUGH mode.
    ///</param>
    ///<returns>True if successful, false if unsuccessful (typically invalid input).</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_SetPrintMode), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_SetPrintMode(int mode);
    ///<summary>Open and load a PDF document.</summary>
    ///<param name = "file_path">Path to the PDF file (including extension).</param>
    ///<param name = "password">
    /// A string used as the password for the PDF file.
    /// If no password is needed, empty or NULL can be used.
    /// See comments below regarding the encoding.
    ///</param>
    ///<remarks>
    /// Loaded document can be closed by FPDF_CloseDocument().
    /// If this function fails, you can use FPDF_GetLastError() to retrieve
    /// the reason why it failed.
    /// The encoding for |password| can be either UTF-8 or Latin-1. PDFs,
    /// depending on the security handler revision, will only accept one or
    /// the other encoding. If |password|'s encoding and the PDF's expected
    /// encoding do not match, FPDF_LoadDocument() will automatically
    /// convert |password| to the other encoding.
    ///</remarks>
    ///<returns>A handle to the loaded document, or NULL on failure.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_LoadDocument), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_LoadDocument(typedef const char* FPDF_STRING file_path, typedef const char* FPDF_BYTESTRING password);
    ///<summary>Open and load a PDF document from memory.</summary>
    ///<param name = "data_buf">Pointer to a buffer containing the PDF document.</param>
    ///<param name = "size">Number of bytes in the PDF document.</param>
    ///<param name = "password">
    /// A string used as the password for the PDF file.
    /// If no password is needed, empty or NULL can be used.
    ///</param>
    ///<remarks>
    /// The memory buffer must remain valid when the document is open.
    /// The loaded document can be closed by FPDF_CloseDocument.
    /// If this function fails, you can use FPDF_GetLastError() to retrieve
    /// the reason why it failed.
    /// See the comments for FPDF_LoadDocument() regarding the encoding for
    /// |password|.
    /// Notes:
    /// If PDFium is built with the XFA module, the application should call
    /// FPDF_LoadXFA() function after the PDF document loaded to support XFA
    /// fields defined in the fpdfformfill.h file.
    ///</remarks>
    ///<returns>A handle to the loaded document, or NULL on failure.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_LoadMemDocument), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_LoadMemDocument(const void* data_buf, int size, typedef const char* FPDF_BYTESTRING password);
    ///<summary>Open and load a PDF document from memory.</summary>
    ///<param name = "data_buf">Pointer to a buffer containing the PDF document.</param>
    ///<param name = "size">Number of bytes in the PDF document.</param>
    ///<param name = "password">
    /// A string used as the password for the PDF file.
    /// If no password is needed, empty or NULL can be used.
    ///</param>
    ///<remarks>
    /// The memory buffer must remain valid when the document is open.
    /// The loaded document can be closed by FPDF_CloseDocument.
    /// If this function fails, you can use FPDF_GetLastError() to retrieve
    /// the reason why it failed.
    /// See the comments for FPDF_LoadDocument() regarding the encoding for
    /// |password|.
    /// Notes:
    /// If PDFium is built with the XFA module, the application should call
    /// FPDF_LoadXFA() function after the PDF document loaded to support XFA
    /// fields defined in the fpdfformfill.h file.
    ///</remarks>
    ///<returns>A handle to the loaded document, or NULL on failure.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_LoadMemDocument64), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_LoadMemDocument64(const void* data_buf, typedef unsigned long long size_t size, typedef const char* FPDF_BYTESTRING password);
    ///<summary>Load PDF document from a custom access descriptor.</summary>
    ///<param name = "pFileAccess">A structure for accessing the file.</param>
    ///<param name = "password">Optional password for decrypting the PDF file.</param>
    ///<remarks>
    /// The application must keep the file resources |pFileAccess| points to
    /// valid until the returned FPDF_DOCUMENT is closed. |pFileAccess|
    /// itself does not need to outlive the FPDF_DOCUMENT.
    /// The loaded document can be closed with FPDF_CloseDocument().
    /// See the comments for FPDF_LoadDocument() regarding the encoding for
    /// |password|.
    /// Notes:
    /// If PDFium is built with the XFA module, the application should call
    /// FPDF_LoadXFA() function after the PDF document loaded to support XFA
    /// fields defined in the fpdfformfill.h file.
    ///</remarks>
    ///<returns>A handle to the loaded document, or NULL on failure.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_LoadCustomDocument), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_LoadCustomDocument(FPDF_FILEACCESS* pFileAccess, typedef const char* FPDF_BYTESTRING password);
    ///<summary>Get the file version of the given PDF document.</summary>
    ///<param name = "doc">Handle to a document.</param>
    ///<param name = "fileVersion">
    /// The PDF file version. File version: 14 for 1.4, 15
    /// for 1.5, ...
    ///</param>
    ///<remarks>
    /// If the document was created by FPDF_CreateNewDocument,
    /// then this function will always fail.
    ///</remarks>
    ///<returns>True if succeeds, false otherwise.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_GetFileVersion), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_GetFileVersion(typedef fpdf_document_t__* FPDF_DOCUMENT doc, int* fileVersion);
    ///<summary>Get last error code when a function fails.</summary>
    ///<remarks>
    /// If the previous SDK call succeeded, the return value of this
    /// function is not defined.
    ///</remarks>
    ///<returns>A 32-bit integer indicating error code as defined above.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_GetLastError), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_GetLastError();
    ///<summary>Whether the document's cross reference table is valid or not.</summary>
    ///<param name = "document">Handle to a document. Returned by FPDF_LoadDocument.</param>
    ///<remarks>The return value can change over time as the PDF parser evolves.</remarks>
    ///<returns>
    /// True if the PDF parser did not encounter problems parsing the cross
    /// reference table. False if the parser could not parse the cross
    /// reference table and the table had to be rebuild from other data
    /// within the document.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_DocumentHasValidCrossReferenceTable), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_DocumentHasValidCrossReferenceTable(typedef fpdf_document_t__* FPDF_DOCUMENT document);
    ///<summary>Get the byte offsets of trailer ends.</summary>
    ///<param name = "document">Handle to document. Returned by FPDF_LoadDocument().</param>
    ///<param name = "buffer">
    /// The address of a buffer that receives the
    /// byte offsets.
    ///</param>
    ///<param name = "length">The size, in ints, of |buffer|.</param>
    ///<returns>
    /// Returns the number of ints in the buffer on success, 0 on error.
    /// |buffer| is an array of integers that describes the exact byte offsets of the
    /// trailer ends in the document. If |length| is less than the returned length,
    /// or |document| or |buffer| is NULL, |buffer| will not be modified.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_GetTrailerEnds), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_GetTrailerEnds(typedef fpdf_document_t__* FPDF_DOCUMENT document, unsigned int* buffer, unsigned int length);
    ///<summary>Get file permission flags of the document.</summary>
    ///<param name = "document">Handle to a document. Returned by FPDF_LoadDocument.</param>
    ///<returns>
    /// A 32-bit integer indicating permission flags. Please refer to the
    /// PDF Reference for detailed descriptions. If the document is not
    /// protected, 0xffffffff will be returned.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_GetDocPermissions), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_GetDocPermissions(typedef fpdf_document_t__* FPDF_DOCUMENT document);
    ///<summary>Get the revision for the security handler.</summary>
    ///<param name = "document">Handle to a document. Returned by FPDF_LoadDocument.</param>
    ///<returns>
    /// The security handler revision number. Please refer to the PDF
    /// Reference for a detailed description. If the document is not
    /// protected, -1 will be returned.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_GetSecurityHandlerRevision), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_GetSecurityHandlerRevision(typedef fpdf_document_t__* FPDF_DOCUMENT document);
    ///<summary>Get total number of pages in the document.</summary>
    ///<param name = "document">Handle to document. Returned by FPDF_LoadDocument.</param>
    ///<returns>Total number of pages in the document.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_GetPageCount), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_GetPageCount(typedef fpdf_document_t__* FPDF_DOCUMENT document);
    ///<summary>Load a page inside the document.</summary>
    ///<param name = "document">Handle to document. Returned by FPDF_LoadDocument</param>
    ///<param name = "page_index">Index number of the page. 0 for the first page.</param>
    ///<remarks>
    /// The loaded page can be rendered to devices using FPDF_RenderPage.
    /// The loaded page can be closed using FPDF_ClosePage.
    ///</remarks>
    ///<returns>A handle to the loaded page, or NULL if page load fails.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_LoadPage), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_LoadPage(typedef fpdf_document_t__* FPDF_DOCUMENT document, int page_index);
    ///<summary>Get page width.</summary>
    ///<param name = "page">Handle to the page. Returned by FPDF_LoadPage().</param>
    ///<returns>
    /// Page width (excluding non-displayable area) measured in points.
    /// One point is 1/72 inch (around 0.3528 mm).
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_GetPageWidthF), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_GetPageWidthF(typedef fpdf_page_t__* FPDF_PAGE page);
    ///<summary>Get page width.</summary>
    ///<param name = "page">Handle to the page. Returned by FPDF_LoadPage.</param>
    ///<returns>
    /// Page width (excluding non-displayable area) measured in points.
    /// One point is 1/72 inch (around 0.3528 mm).
    /// Note:
    /// Prefer FPDF_GetPageWidthF() above. This will be deprecated in the
    /// future.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_GetPageWidth), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_GetPageWidth(typedef fpdf_page_t__* FPDF_PAGE page);
    ///<summary>Get page height.</summary>
    ///<param name = "page">Handle to the page. Returned by FPDF_LoadPage().</param>
    ///<returns>
    /// Page height (excluding non-displayable area) measured in points.
    /// One point is 1/72 inch (around 0.3528 mm)
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_GetPageHeightF), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_GetPageHeightF(typedef fpdf_page_t__* FPDF_PAGE page);
    ///<summary>Get page height.</summary>
    ///<param name = "page">Handle to the page. Returned by FPDF_LoadPage.</param>
    ///<returns>
    /// Page height (excluding non-displayable area) measured in points.
    /// One point is 1/72 inch (around 0.3528 mm)
    /// Note:
    /// Prefer FPDF_GetPageHeightF() above. This will be deprecated in the
    /// future.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_GetPageHeight), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_GetPageHeight(typedef fpdf_page_t__* FPDF_PAGE page);
    ///<summary>
    /// Get the bounding box of the page. This is the intersection between
    /// its media box and its crop box.
    ///</summary>
    ///<param name = "page">Handle to the page. Returned by FPDF_LoadPage.</param>
    ///<param name = "rect">
    /// Pointer to a rect to receive the page bounding box.
    /// On an error, |rect| won't be filled.
    ///</param>
    ///<returns>True for success.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_GetPageBoundingBox), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_GetPageBoundingBox(typedef fpdf_page_t__* FPDF_PAGE page, FS_RECTF* rect);
    ///<summary>Get the size of the page at the given index.</summary>
    ///<param name = "document">Handle to document. Returned by FPDF_LoadDocument().</param>
    ///<param name = "page_index">Page index, zero for the first page.</param>
    ///<param name = "size">
    /// Pointer to a FS_SIZEF to receive the page size.
    /// (in points).
    ///</param>
    ///<returns>Non-zero for success. 0 for error (document or page not found).</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_GetPageSizeByIndexF), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_GetPageSizeByIndexF(typedef fpdf_document_t__* FPDF_DOCUMENT document, int page_index, FS_SIZEF* size);
    ///<summary>Get the size of the page at the given index.</summary>
    ///<param name = "document">Handle to document. Returned by FPDF_LoadDocument.</param>
    ///<param name = "page_index">Page index, zero for the first page.</param>
    ///<param name = "width">
    /// Pointer to a double to receive the page width
    /// (in points).
    ///</param>
    ///<param name = "height">
    /// Pointer to a double to receive the page height
    /// (in points).
    ///</param>
    ///<returns>
    /// Non-zero for success. 0 for error (document or page not found).
    /// Note:
    /// Prefer FPDF_GetPageSizeByIndexF() above. This will be deprecated in
    /// the future.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_GetPageSizeByIndex), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_GetPageSizeByIndex(typedef fpdf_document_t__* FPDF_DOCUMENT document, int page_index, double* width, double* height);
    ///<summary>
    /// Render contents of a page to a device (screen, bitmap, or printer).
    /// This function is only supported on Windows.
    ///</summary>
    ///<param name = "dc">Handle to the device context.</param>
    ///<param name = "page">Handle to the page. Returned by FPDF_LoadPage.</param>
    ///<param name = "start_x">
    /// Left pixel position of the display area in
    /// device coordinates.
    ///</param>
    ///<param name = "start_y">
    /// Top pixel position of the display area in device
    /// coordinates.
    ///</param>
    ///<param name = "size_x">Horizontal size (in pixels) for displaying the page.</param>
    ///<param name = "size_y">Vertical size (in pixels) for displaying the page.</param>
    ///<param name = "rotate">
    /// Page orientation:
    /// 0 (normal)
    /// 1 (rotated 90 degrees clockwise)
    /// 2 (rotated 180 degrees)
    /// 3 (rotated 90 degrees counter-clockwise)
    ///</param>
    ///<param name = "flags">
    /// 0 for normal display, or combination of flags
    /// defined above.
    ///</param>
    [DllImport(DllName, EntryPoint = nameof(FPDF_RenderPage), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_RenderPage(typedef HDC__* HDC dc, typedef fpdf_page_t__* FPDF_PAGE page, int start_x, int start_y, int size_x, int size_y, int rotate, int flags);
    ///<summary>Render contents of a page to a device independent bitmap.</summary>
    ///<param name = "bitmap">
    /// Handle to the device independent bitmap (as the
    /// output buffer). The bitmap handle can be created
    /// by FPDFBitmap_Create or retrieved from an image
    /// object by FPDFImageObj_GetBitmap.
    ///</param>
    ///<param name = "page">Handle to the page. Returned by FPDF_LoadPage</param>
    ///<param name = "start_x">
    /// Left pixel position of the display area in
    /// bitmap coordinates.
    ///</param>
    ///<param name = "start_y">
    /// Top pixel position of the display area in bitmap
    /// coordinates.
    ///</param>
    ///<param name = "size_x">Horizontal size (in pixels) for displaying the page.</param>
    ///<param name = "size_y">Vertical size (in pixels) for displaying the page.</param>
    ///<param name = "rotate">
    /// Page orientation:
    /// 0 (normal)
    /// 1 (rotated 90 degrees clockwise)
    /// 2 (rotated 180 degrees)
    /// 3 (rotated 90 degrees counter-clockwise)
    ///</param>
    ///<param name = "flags">
    /// 0 for normal display, or combination of the Page
    /// Rendering flags defined above. With the FPDF_ANNOT
    /// flag, it renders all annotations that do not require
    /// user-interaction, which are all annotations except
    /// widget and popup annotations.
    ///</param>
    [DllImport(DllName, EntryPoint = nameof(FPDF_RenderPageBitmap), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_RenderPageBitmap(typedef fpdf_bitmap_t__* FPDF_BITMAP bitmap, typedef fpdf_page_t__* FPDF_PAGE page, int start_x, int start_y, int size_x, int size_y, int rotate, int flags);
    ///<summary>Render contents of a page to a device independent bitmap.</summary>
    ///<param name = "bitmap">
    /// Handle to the device independent bitmap (as the
    /// output buffer). The bitmap handle can be created
    /// by FPDFBitmap_Create or retrieved by
    /// FPDFImageObj_GetBitmap.
    ///</param>
    ///<param name = "page">Handle to the page. Returned by FPDF_LoadPage.</param>
    ///<param name = "matrix">
    /// The transform matrix, which must be invertible.
    /// See PDF Reference 1.7, 4.2.2 Common Transformations.
    ///</param>
    ///<param name = "clipping">The rect to clip to in device coords.</param>
    ///<param name = "flags">
    /// 0 for normal display, or combination of the Page
    /// Rendering flags defined above. With the FPDF_ANNOT
    /// flag, it renders all annotations that do not require
    /// user-interaction, which are all annotations except
    /// widget and popup annotations.
    ///</param>
    [DllImport(DllName, EntryPoint = nameof(FPDF_RenderPageBitmapWithMatrix), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_RenderPageBitmapWithMatrix(typedef fpdf_bitmap_t__* FPDF_BITMAP bitmap, typedef fpdf_page_t__* FPDF_PAGE page, const FS_MATRIX* matrix, const FS_RECTF* clipping, int flags);
    ///<summary>Close a loaded PDF page.</summary>
    ///<param name = "page">Handle to the loaded page.</param>
    [DllImport(DllName, EntryPoint = nameof(FPDF_ClosePage), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_ClosePage(typedef fpdf_page_t__* FPDF_PAGE page);
    ///<summary>Close a loaded PDF document.</summary>
    ///<param name = "document">Handle to the loaded document.</param>
    [DllImport(DllName, EntryPoint = nameof(FPDF_CloseDocument), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_CloseDocument(typedef fpdf_document_t__* FPDF_DOCUMENT document);
    ///<summary>Convert the screen coordinates of a point to page coordinates.</summary>
    ///<param name = "page">Handle to the page. Returned by FPDF_LoadPage.</param>
    ///<param name = "start_x">
    /// Left pixel position of the display area in
    /// device coordinates.
    ///</param>
    ///<param name = "start_y">
    /// Top pixel position of the display area in device
    /// coordinates.
    ///</param>
    ///<param name = "size_x">Horizontal size (in pixels) for displaying the page.</param>
    ///<param name = "size_y">Vertical size (in pixels) for displaying the page.</param>
    ///<param name = "rotate">
    /// Page orientation:
    /// 0 (normal)
    /// 1 (rotated 90 degrees clockwise)
    /// 2 (rotated 180 degrees)
    /// 3 (rotated 90 degrees counter-clockwise)
    ///</param>
    ///<param name = "device_x">X value in device coordinates to be converted.</param>
    ///<param name = "device_y">Y value in device coordinates to be converted.</param>
    ///<param name = "page_x">
    /// A pointer to a double receiving the converted X
    /// value in page coordinates.
    ///</param>
    ///<param name = "page_y">
    /// A pointer to a double receiving the converted Y
    /// value in page coordinates.
    ///</param>
    ///<remarks>
    /// The page coordinate system has its origin at the left-bottom corner
    /// of the page, with the X-axis on the bottom going to the right, and
    /// the Y-axis on the left side going up.
    /// NOTE: this coordinate system can be altered when you zoom, scroll,
    /// or rotate a page, however, a point on the page should always have
    /// the same coordinate values in the page coordinate system.
    /// The device coordinate system is device dependent. For screen device,
    /// its origin is at the left-top corner of the window. However this
    /// origin can be altered by the Windows coordinate transformation
    /// utilities.
    /// You must make sure the start_x, start_y, size_x, size_y
    /// and rotate parameters have exactly same values as you used in
    /// the FPDF_RenderPage() function call.
    ///</remarks>
    ///<returns>
    /// Returns true if the conversion succeeds, and |page_x| and |page_y|
    /// successfully receives the converted coordinates.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_DeviceToPage), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_DeviceToPage(typedef fpdf_page_t__* FPDF_PAGE page, int start_x, int start_y, int size_x, int size_y, int rotate, int device_x, int device_y, double* page_x, double* page_y);
    ///<summary>Convert the page coordinates of a point to screen coordinates.</summary>
    ///<param name = "page">Handle to the page. Returned by FPDF_LoadPage.</param>
    ///<param name = "start_x">
    /// Left pixel position of the display area in
    /// device coordinates.
    ///</param>
    ///<param name = "start_y">
    /// Top pixel position of the display area in device
    /// coordinates.
    ///</param>
    ///<param name = "size_x">Horizontal size (in pixels) for displaying the page.</param>
    ///<param name = "size_y">Vertical size (in pixels) for displaying the page.</param>
    ///<param name = "rotate">
    /// Page orientation:
    /// 0 (normal)
    /// 1 (rotated 90 degrees clockwise)
    /// 2 (rotated 180 degrees)
    /// 3 (rotated 90 degrees counter-clockwise)
    ///</param>
    ///<param name = "page_x">X value in page coordinates.</param>
    ///<param name = "page_y">Y value in page coordinate.</param>
    ///<param name = "device_x">
    /// A pointer to an integer receiving the result X
    /// value in device coordinates.
    ///</param>
    ///<param name = "device_y">
    /// A pointer to an integer receiving the result Y
    /// value in device coordinates.
    ///</param>
    ///<remarks>See comments for FPDF_DeviceToPage().</remarks>
    ///<returns>
    /// Returns true if the conversion succeeds, and |device_x| and
    /// |device_y| successfully receives the converted coordinates.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_PageToDevice), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_PageToDevice(typedef fpdf_page_t__* FPDF_PAGE page, int start_x, int start_y, int size_x, int size_y, int rotate, double page_x, double page_y, int* device_x, int* device_y);
    ///<summary>Create a device independent bitmap (FXDIB).</summary>
    ///<param name = "width">
    /// The number of pixels in width for the bitmap.
    /// Must be greater than 0.
    ///</param>
    ///<param name = "height">
    /// The number of pixels in height for the bitmap.
    /// Must be greater than 0.
    ///</param>
    ///<param name = "alpha">
    /// A flag indicating whether the alpha channel is used.
    /// Non-zero for using alpha, zero for not using.
    ///</param>
    ///<remarks>
    /// The bitmap always uses 4 bytes per pixel. The first byte is always
    /// double word aligned.
    /// The byte order is BGRx (the last byte unused if no alpha channel) or
    /// BGRA.
    /// The pixels in a horizontal line are stored side by side, with the
    /// left most pixel stored first (with lower memory address).
    /// Each line uses width * 4 bytes.
    /// Lines are stored one after another, with the top most line stored
    /// first. There is no gap between adjacent lines.
    /// This function allocates enough memory for holding all pixels in the
    /// bitmap, but it doesn't initialize the buffer. Applications can use
    /// FPDFBitmap_FillRect() to fill the bitmap using any color. If the OS
    /// allows it, this function can allocate up to 4 GB of memory.
    ///</remarks>
    ///<returns>
    /// The created bitmap handle, or NULL if a parameter error or out of
    /// memory.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFBitmap_Create), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFBitmap_Create(int width, int height, int alpha);
    ///<summary>Create a device independent bitmap (FXDIB)</summary>
    ///<param name = "width">
    /// The number of pixels in width for the bitmap.
    /// Must be greater than 0.
    ///</param>
    ///<param name = "height">
    /// The number of pixels in height for the bitmap.
    /// Must be greater than 0.
    ///</param>
    ///<param name = "format">
    /// A number indicating for bitmap format, as defined
    /// above.
    ///</param>
    ///<param name = "first_scan">
    /// A pointer to the first byte of the first line if
    /// using an external buffer. If this parameter is NULL,
    /// then the a new buffer will be created.
    ///</param>
    ///<param name = "stride">
    /// Number of bytes for each scan line, for external
    /// buffer only.
    ///</param>
    ///<remarks>
    /// Similar to FPDFBitmap_Create function, but allows for more formats
    /// and an external buffer is supported. The bitmap created by this
    /// function can be used in any place that a FPDF_BITMAP handle is
    /// required.
    /// If an external buffer is used, then the application should destroy
    /// the buffer by itself. FPDFBitmap_Destroy function will not destroy
    /// the buffer.
    ///</remarks>
    ///<returns>The bitmap handle, or NULL if parameter error or out of memory.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFBitmap_CreateEx), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFBitmap_CreateEx(int width, int height, int format, void* first_scan, int stride);
    ///<summary>Get the format of the bitmap.</summary>
    ///<param name = "bitmap">
    /// Handle to the bitmap. Returned by FPDFBitmap_Create
    /// or FPDFImageObj_GetBitmap.
    ///</param>
    ///<remarks>
    /// Only formats supported by FPDFBitmap_CreateEx are supported by this
    /// function; see the list of such formats above.
    ///</remarks>
    ///<returns>The format of the bitmap.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFBitmap_GetFormat), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFBitmap_GetFormat(typedef fpdf_bitmap_t__* FPDF_BITMAP bitmap);
    ///<summary>Fill a rectangle in a bitmap.</summary>
    ///<param name = "bitmap">
    /// The handle to the bitmap. Returned by
    /// FPDFBitmap_Create.
    ///</param>
    ///<param name = "left">
    /// The left position. Starting from 0 at the
    /// left-most pixel.
    ///</param>
    ///<param name = "top">
    /// The top position. Starting from 0 at the
    /// top-most line.
    ///</param>
    ///<param name = "width">Width in pixels to be filled.</param>
    ///<param name = "height">Height in pixels to be filled.</param>
    ///<param name = "color">
    /// A 32-bit value specifing the color, in 8888 ARGB
    /// format.
    ///</param>
    ///<remarks>
    /// This function sets the color and (optionally) alpha value in the
    /// specified region of the bitmap.
    /// NOTE: If the alpha channel is used, this function does NOT
    /// composite the background with the source color, instead the
    /// background will be replaced by the source color and the alpha.
    /// If the alpha channel is not used, the alpha parameter is ignored.
    ///</remarks>
    [DllImport(DllName, EntryPoint = nameof(FPDFBitmap_FillRect), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFBitmap_FillRect(typedef fpdf_bitmap_t__* FPDF_BITMAP bitmap, int left, int top, int width, int height, typedef unsigned int FPDF_DWORD color);
    ///<summary>Get data buffer of a bitmap.</summary>
    ///<param name = "bitmap">
    /// Handle to the bitmap. Returned by FPDFBitmap_Create
    /// or FPDFImageObj_GetBitmap.
    ///</param>
    ///<remarks>
    /// The stride may be more than width * number of bytes per pixel
    /// Applications can use this function to get the bitmap buffer pointer,
    /// then manipulate any color and/or alpha values for any pixels in the
    /// bitmap.
    /// The data is in BGRA format. Where the A maybe unused if alpha was
    /// not specified.
    ///</remarks>
    ///<returns>The pointer to the first byte of the bitmap buffer.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFBitmap_GetBuffer), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFBitmap_GetBuffer(typedef fpdf_bitmap_t__* FPDF_BITMAP bitmap);
    ///<summary>Get width of a bitmap.</summary>
    ///<param name = "bitmap">
    /// Handle to the bitmap. Returned by FPDFBitmap_Create
    /// or FPDFImageObj_GetBitmap.
    ///</param>
    ///<returns>The width of the bitmap in pixels.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFBitmap_GetWidth), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFBitmap_GetWidth(typedef fpdf_bitmap_t__* FPDF_BITMAP bitmap);
    ///<summary>Get height of a bitmap.</summary>
    ///<param name = "bitmap">
    /// Handle to the bitmap. Returned by FPDFBitmap_Create
    /// or FPDFImageObj_GetBitmap.
    ///</param>
    ///<returns>The height of the bitmap in pixels.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFBitmap_GetHeight), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFBitmap_GetHeight(typedef fpdf_bitmap_t__* FPDF_BITMAP bitmap);
    ///<summary>Get number of bytes for each line in the bitmap buffer.</summary>
    ///<param name = "bitmap">
    /// Handle to the bitmap. Returned by FPDFBitmap_Create
    /// or FPDFImageObj_GetBitmap.
    ///</param>
    ///<remarks>The stride may be more than width * number of bytes per pixel.</remarks>
    ///<returns>The number of bytes for each line in the bitmap buffer.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFBitmap_GetStride), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFBitmap_GetStride(typedef fpdf_bitmap_t__* FPDF_BITMAP bitmap);
    ///<summary>Destroy a bitmap and release all related buffers.</summary>
    ///<param name = "bitmap">
    /// Handle to the bitmap. Returned by FPDFBitmap_Create
    /// or FPDFImageObj_GetBitmap.
    ///</param>
    ///<remarks>
    /// This function will not destroy any external buffers provided when
    /// the bitmap was created.
    ///</remarks>
    [DllImport(DllName, EntryPoint = nameof(FPDFBitmap_Destroy), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFBitmap_Destroy(typedef fpdf_bitmap_t__* FPDF_BITMAP bitmap);
    ///<summary>Whether the PDF document prefers to be scaled or not.</summary>
    ///<param name = "document">Handle to the loaded document.</param>
    [DllImport(DllName, EntryPoint = nameof(FPDF_VIEWERREF_GetPrintScaling), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_VIEWERREF_GetPrintScaling(typedef fpdf_document_t__* FPDF_DOCUMENT document);
    ///<summary>Returns the number of copies to be printed.</summary>
    ///<param name = "document">Handle to the loaded document.</param>
    ///<returns>The number of copies to be printed.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_VIEWERREF_GetNumCopies), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_VIEWERREF_GetNumCopies(typedef fpdf_document_t__* FPDF_DOCUMENT document);
    ///<summary>Page numbers to initialize print dialog box when file is printed.</summary>
    ///<param name = "document">Handle to the loaded document.</param>
    ///<returns>The print page range to be used for printing.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_VIEWERREF_GetPrintPageRange), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_VIEWERREF_GetPrintPageRange(typedef fpdf_document_t__* FPDF_DOCUMENT document);
    ///<summary>Returns the number of elements in a FPDF_PAGERANGE.</summary>
    ///<param name = "pagerange">Handle to the page range.</param>
    ///<returns>The number of elements in the page range. Returns 0 on error.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_VIEWERREF_GetPrintPageRangeCount), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_VIEWERREF_GetPrintPageRangeCount(typedef fpdf_pagerange_t__* FPDF_PAGERANGE pagerange);
    ///<summary>Returns an element from a FPDF_PAGERANGE.</summary>
    ///<param name = "pagerange">Handle to the page range.</param>
    ///<param name = "index">Index of the element.</param>
    ///<returns>
    /// The value of the element in the page range at a given index.
    /// Returns -1 on error.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_VIEWERREF_GetPrintPageRangeElement), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_VIEWERREF_GetPrintPageRangeElement(typedef fpdf_pagerange_t__* FPDF_PAGERANGE pagerange, typedef unsigned long long size_t index);
    ///<summary>
    /// Returns the paper handling option to be used when printing from
    /// the print dialog.
    ///</summary>
    ///<param name = "document">Handle to the loaded document.</param>
    ///<returns>The paper handling option to be used when printing.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_VIEWERREF_GetDuplex), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_VIEWERREF_GetDuplex(typedef fpdf_document_t__* FPDF_DOCUMENT document);
    ///<summary>
    /// Gets the contents for a viewer ref, with a given key. The value must
    /// be of type "name".
    ///</summary>
    ///<param name = "document">Handle to the loaded document.</param>
    ///<param name = "key">
    /// Name of the key in the viewer pref dictionary,
    /// encoded in UTF-8.
    ///</param>
    ///<param name = "buffer">A string to write the contents of the key to.</param>
    ///<param name = "length">Length of the buffer.</param>
    ///<returns>
    /// The number of bytes in the contents, including the NULL terminator.
    /// Thus if the return value is 0, then that indicates an error, such
    /// as when |document| is invalid or |buffer| is NULL. If |length| is
    /// less than the returned length, or |buffer| is NULL, |buffer| will
    /// not be modified.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_VIEWERREF_GetName), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_VIEWERREF_GetName(typedef fpdf_document_t__* FPDF_DOCUMENT document, typedef const char* FPDF_BYTESTRING key, char* buffer, unsigned int length);
    ///<summary>Get the count of named destinations in the PDF document.</summary>
    ///<param name = "document">Handle to a document</param>
    ///<returns>The count of named destinations.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_CountNamedDests), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_CountNamedDests(typedef fpdf_document_t__* FPDF_DOCUMENT document);
    ///<summary>Get a the destination handle for the given name.</summary>
    ///<param name = "document">Handle to the loaded document.</param>
    ///<param name = "name">The name of a destination.</param>
    ///<returns>The handle to the destination.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_GetNamedDestByName), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_GetNamedDestByName(typedef fpdf_document_t__* FPDF_DOCUMENT document, typedef const char* FPDF_BYTESTRING name);
    ///<summary>Get the named destination by index.</summary>
    ///<param name = "document">Handle to a document</param>
    ///<param name = "index">The index of a named destination.</param>
    ///<param name = "buffer">
    /// The buffer to store the destination name,
    /// used as wchar_t*.
    ///</param>
    ///<param name = "buflen [in/out]">
    /// Size of the buffer in bytes on input,
    /// length of the result in bytes on output
    /// or -1 if the buffer is too small.
    ///</param>
    ///<remarks>
    /// Call this function twice to get the name of the named destination:
    /// 1) First time pass in |buffer| as NULL and get buflen.
    /// 2) Second time pass in allocated |buffer| and buflen to retrieve
    /// |buffer|, which should be used as wchar_t*.
    /// If buflen is not sufficiently large, it will be set to -1 upon
    /// return.
    ///</remarks>
    ///<returns>
    /// The destination handle for a given index, or NULL if there is no
    /// named destination corresponding to |index|.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_GetNamedDest), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_GetNamedDest(typedef fpdf_document_t__* FPDF_DOCUMENT document, int index, void* buffer, int* buflen);
    ///<summary>Get the number of valid packets in the XFA entry.</summary>
    ///<param name = "document">Handle to the document.</param>
    ///<returns>The number of valid packets, or -1 on error.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_GetXFAPacketCount), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_GetXFAPacketCount(typedef fpdf_document_t__* FPDF_DOCUMENT document);
    ///<summary>Get the name of a packet in the XFA array.</summary>
    ///<param name = "document">Handle to the document.</param>
    ///<param name = "index">Index number of the packet. 0 for the first packet.</param>
    ///<param name = "buffer">Buffer for holding the name of the XFA packet.</param>
    ///<param name = "buflen">Length of |buffer| in bytes.</param>
    ///<returns>
    /// The length of the packet name in bytes, or 0 on error.
    /// |document| must be valid and |index| must be in the range [0, N), where N is
    /// the value returned by FPDF_GetXFAPacketCount().
    /// |buffer| is only modified if it is non-NULL and |buflen| is greater than or
    /// equal to the length of the packet name. The packet name includes a
    /// terminating NUL character. |buffer| is unmodified on error.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_GetXFAPacketName), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_GetXFAPacketName(typedef fpdf_document_t__* FPDF_DOCUMENT document, int index, void* buffer, unsigned int buflen);
    ///<summary>Get the content of a packet in the XFA array.</summary>
    ///<param name = "document">Handle to the document.</param>
    ///<param name = "index">Index number of the packet. 0 for the first packet.</param>
    ///<param name = "buffer">Buffer for holding the content of the XFA packet.</param>
    ///<param name = "buflen">Length of |buffer| in bytes.</param>
    ///<param name = "out_buflen">
    /// Pointer to the variable that will receive the minimum
    /// buffer size needed to contain the content of the XFA
    /// packet.
    ///</param>
    ///<returns>
    /// Whether the operation succeeded or not.
    /// |document| must be valid and |index| must be in the range [0, N), where N is
    /// the value returned by FPDF_GetXFAPacketCount(). |out_buflen| must not be
    /// NULL. When the aforementioned arguments are valid, the operation succeeds,
    /// and |out_buflen| receives the content size. |buffer| is only modified if
    /// |buffer| is non-null and long enough to contain the content. Callers must
    /// check both the return value and the input |buflen| is no less than the
    /// returned |out_buflen| before using the data in |buffer|.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_GetXFAPacketContent), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_GetXFAPacketContent(typedef fpdf_document_t__* FPDF_DOCUMENT document, int index, void* buffer, unsigned int buflen, unsigned int* out_buflen);
    [DllImport(DllName, EntryPoint = nameof(FPDFBookmark_GetFirstChild), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFBookmark_GetFirstChild(typedef fpdf_document_t__* FPDF_DOCUMENT document, typedef fpdf_bookmark_t__* FPDF_BOOKMARK bookmark);
    [DllImport(DllName, EntryPoint = nameof(FPDFBookmark_GetNextSibling), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFBookmark_GetNextSibling(typedef fpdf_document_t__* FPDF_DOCUMENT document, typedef fpdf_bookmark_t__* FPDF_BOOKMARK bookmark);
    [DllImport(DllName, EntryPoint = nameof(FPDFBookmark_GetTitle), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFBookmark_GetTitle(typedef fpdf_bookmark_t__* FPDF_BOOKMARK bookmark, void* buffer, unsigned int buflen);
    [DllImport(DllName, EntryPoint = nameof(FPDFBookmark_Find), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFBookmark_Find(typedef fpdf_document_t__* FPDF_DOCUMENT document, typedef const unsigned short* FPDF_WIDESTRING title);
    [DllImport(DllName, EntryPoint = nameof(FPDFBookmark_GetDest), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFBookmark_GetDest(typedef fpdf_document_t__* FPDF_DOCUMENT document, typedef fpdf_bookmark_t__* FPDF_BOOKMARK bookmark);
    [DllImport(DllName, EntryPoint = nameof(FPDFBookmark_GetAction), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFBookmark_GetAction(typedef fpdf_bookmark_t__* FPDF_BOOKMARK bookmark);
    [DllImport(DllName, EntryPoint = nameof(FPDFAction_GetType), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFAction_GetType(typedef fpdf_action_t__* FPDF_ACTION action);
    [DllImport(DllName, EntryPoint = nameof(FPDFAction_GetDest), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFAction_GetDest(typedef fpdf_document_t__* FPDF_DOCUMENT document, typedef fpdf_action_t__* FPDF_ACTION action);
    [DllImport(DllName, EntryPoint = nameof(FPDFAction_GetFilePath), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFAction_GetFilePath(typedef fpdf_action_t__* FPDF_ACTION action, void* buffer, unsigned int buflen);
    [DllImport(DllName, EntryPoint = nameof(FPDFAction_GetURIPath), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFAction_GetURIPath(typedef fpdf_document_t__* FPDF_DOCUMENT document, typedef fpdf_action_t__* FPDF_ACTION action, void* buffer, unsigned int buflen);
    [DllImport(DllName, EntryPoint = nameof(FPDFDest_GetDestPageIndex), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFDest_GetDestPageIndex(typedef fpdf_document_t__* FPDF_DOCUMENT document, typedef fpdf_dest_t__* FPDF_DEST dest);
    [DllImport(DllName, EntryPoint = nameof(FPDFDest_GetView), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFDest_GetView(typedef fpdf_dest_t__* FPDF_DEST dest, unsigned int* pNumParams, FS_FLOAT* pParams);
    [DllImport(DllName, EntryPoint = nameof(FPDFDest_GetLocationInPage), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFDest_GetLocationInPage(typedef fpdf_dest_t__* FPDF_DEST dest, FPDF_BOOL* hasXVal, FPDF_BOOL* hasYVal, FPDF_BOOL* hasZoomVal, FS_FLOAT* x, FS_FLOAT* y, FS_FLOAT* zoom);
    [DllImport(DllName, EntryPoint = nameof(FPDFLink_GetLinkAtPoint), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFLink_GetLinkAtPoint(typedef fpdf_page_t__* FPDF_PAGE page, double x, double y);
    [DllImport(DllName, EntryPoint = nameof(FPDFLink_GetLinkZOrderAtPoint), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFLink_GetLinkZOrderAtPoint(typedef fpdf_page_t__* FPDF_PAGE page, double x, double y);
    [DllImport(DllName, EntryPoint = nameof(FPDFLink_GetDest), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFLink_GetDest(typedef fpdf_document_t__* FPDF_DOCUMENT document, typedef fpdf_link_t__* FPDF_LINK link);
    [DllImport(DllName, EntryPoint = nameof(FPDFLink_GetAction), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFLink_GetAction(typedef fpdf_link_t__* FPDF_LINK link);
    [DllImport(DllName, EntryPoint = nameof(FPDFLink_Enumerate), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFLink_Enumerate(typedef fpdf_page_t__* FPDF_PAGE page, int* start_pos, FPDF_LINK* link_annot);
    [DllImport(DllName, EntryPoint = nameof(FPDFLink_GetAnnot), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFLink_GetAnnot(typedef fpdf_page_t__* FPDF_PAGE page, typedef fpdf_link_t__* FPDF_LINK link_annot);
    [DllImport(DllName, EntryPoint = nameof(FPDFLink_GetAnnotRect), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFLink_GetAnnotRect(typedef fpdf_link_t__* FPDF_LINK link_annot, FS_RECTF* rect);
    [DllImport(DllName, EntryPoint = nameof(FPDFLink_CountQuadPoints), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFLink_CountQuadPoints(typedef fpdf_link_t__* FPDF_LINK link_annot);
    [DllImport(DllName, EntryPoint = nameof(FPDFLink_GetQuadPoints), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFLink_GetQuadPoints(typedef fpdf_link_t__* FPDF_LINK link_annot, int quad_index, FS_QUADPOINTSF* quad_points);
    [DllImport(DllName, EntryPoint = nameof(FPDF_GetPageAAction), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_GetPageAAction(typedef fpdf_page_t__* FPDF_PAGE page, int aa_type);
    [DllImport(DllName, EntryPoint = nameof(FPDF_GetFileIdentifier), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_GetFileIdentifier(typedef fpdf_document_t__* FPDF_DOCUMENT document, enum FPDF_FILEIDTYPE {...} id_type, void* buffer, unsigned int buflen);
    [DllImport(DllName, EntryPoint = nameof(FPDF_GetMetaText), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_GetMetaText(typedef fpdf_document_t__* FPDF_DOCUMENT document, typedef const char* FPDF_BYTESTRING tag, void* buffer, unsigned int buflen);
    [DllImport(DllName, EntryPoint = nameof(FPDF_GetPageLabel), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_GetPageLabel(typedef fpdf_document_t__* FPDF_DOCUMENT document, int page_index, void* buffer, unsigned int buflen);
    [DllImport(DllName, EntryPoint = nameof(FPDF_CreateNewDocument), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_CreateNewDocument();
    [DllImport(DllName, EntryPoint = nameof(FPDFPage_New), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPage_New(typedef fpdf_document_t__* FPDF_DOCUMENT document, int page_index, double width, double height);
    [DllImport(DllName, EntryPoint = nameof(FPDFPage_Delete), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPage_Delete(typedef fpdf_document_t__* FPDF_DOCUMENT document, int page_index);
    [DllImport(DllName, EntryPoint = nameof(FPDFPage_GetRotation), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPage_GetRotation(typedef fpdf_page_t__* FPDF_PAGE page);
    [DllImport(DllName, EntryPoint = nameof(FPDFPage_SetRotation), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPage_SetRotation(typedef fpdf_page_t__* FPDF_PAGE page, int rotate);
    [DllImport(DllName, EntryPoint = nameof(FPDFPage_InsertObject), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPage_InsertObject(typedef fpdf_page_t__* FPDF_PAGE page, typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT page_obj);
    [DllImport(DllName, EntryPoint = nameof(FPDFPage_RemoveObject), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPage_RemoveObject(typedef fpdf_page_t__* FPDF_PAGE page, typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT page_obj);
    [DllImport(DllName, EntryPoint = nameof(FPDFPage_CountObjects), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPage_CountObjects(typedef fpdf_page_t__* FPDF_PAGE page);
    [DllImport(DllName, EntryPoint = nameof(FPDFPage_GetObject), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPage_GetObject(typedef fpdf_page_t__* FPDF_PAGE page, int index);
    [DllImport(DllName, EntryPoint = nameof(FPDFPage_HasTransparency), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPage_HasTransparency(typedef fpdf_page_t__* FPDF_PAGE page);
    [DllImport(DllName, EntryPoint = nameof(FPDFPage_GenerateContent), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPage_GenerateContent(typedef fpdf_page_t__* FPDF_PAGE page);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObj_Destroy), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObj_Destroy(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT page_obj);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObj_HasTransparency), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObj_HasTransparency(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT page_object);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObj_GetType), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObj_GetType(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT page_object);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObj_Transform), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObj_Transform(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT page_object, double a, double b, double c, double d, double e, double f);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObj_GetMatrix), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObj_GetMatrix(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT page_object, FS_MATRIX* matrix);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObj_SetMatrix), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObj_SetMatrix(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT path, const FS_MATRIX* matrix);
    [DllImport(DllName, EntryPoint = nameof(FPDFPage_TransformAnnots), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPage_TransformAnnots(typedef fpdf_page_t__* FPDF_PAGE page, double a, double b, double c, double d, double e, double f);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObj_NewImageObj), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObj_NewImageObj(typedef fpdf_document_t__* FPDF_DOCUMENT document);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObj_CountMarks), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObj_CountMarks(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT page_object);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObj_GetMark), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObj_GetMark(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT page_object, unsigned int index);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObj_AddMark), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObj_AddMark(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT page_object, typedef const char* FPDF_BYTESTRING name);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObj_RemoveMark), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObj_RemoveMark(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT page_object, typedef fpdf_pageobjectmark_t__* FPDF_PAGEOBJECTMARK mark);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObjMark_GetName), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObjMark_GetName(typedef fpdf_pageobjectmark_t__* FPDF_PAGEOBJECTMARK mark, void* buffer, unsigned int buflen, unsigned int* out_buflen);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObjMark_CountParams), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObjMark_CountParams(typedef fpdf_pageobjectmark_t__* FPDF_PAGEOBJECTMARK mark);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObjMark_GetParamKey), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObjMark_GetParamKey(typedef fpdf_pageobjectmark_t__* FPDF_PAGEOBJECTMARK mark, unsigned int index, void* buffer, unsigned int buflen, unsigned int* out_buflen);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObjMark_GetParamValueType), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObjMark_GetParamValueType(typedef fpdf_pageobjectmark_t__* FPDF_PAGEOBJECTMARK mark, typedef const char* FPDF_BYTESTRING key);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObjMark_GetParamIntValue), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObjMark_GetParamIntValue(typedef fpdf_pageobjectmark_t__* FPDF_PAGEOBJECTMARK mark, typedef const char* FPDF_BYTESTRING key, int* out_value);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObjMark_GetParamStringValue), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObjMark_GetParamStringValue(typedef fpdf_pageobjectmark_t__* FPDF_PAGEOBJECTMARK mark, typedef const char* FPDF_BYTESTRING key, void* buffer, unsigned int buflen, unsigned int* out_buflen);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObjMark_GetParamBlobValue), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObjMark_GetParamBlobValue(typedef fpdf_pageobjectmark_t__* FPDF_PAGEOBJECTMARK mark, typedef const char* FPDF_BYTESTRING key, void* buffer, unsigned int buflen, unsigned int* out_buflen);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObjMark_SetIntParam), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObjMark_SetIntParam(typedef fpdf_document_t__* FPDF_DOCUMENT document, typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT page_object, typedef fpdf_pageobjectmark_t__* FPDF_PAGEOBJECTMARK mark, typedef const char* FPDF_BYTESTRING key, int value);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObjMark_SetStringParam), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObjMark_SetStringParam(typedef fpdf_document_t__* FPDF_DOCUMENT document, typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT page_object, typedef fpdf_pageobjectmark_t__* FPDF_PAGEOBJECTMARK mark, typedef const char* FPDF_BYTESTRING key, typedef const char* FPDF_BYTESTRING value);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObjMark_SetBlobParam), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObjMark_SetBlobParam(typedef fpdf_document_t__* FPDF_DOCUMENT document, typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT page_object, typedef fpdf_pageobjectmark_t__* FPDF_PAGEOBJECTMARK mark, typedef const char* FPDF_BYTESTRING key, void* value, unsigned int value_len);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObjMark_RemoveParam), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObjMark_RemoveParam(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT page_object, typedef fpdf_pageobjectmark_t__* FPDF_PAGEOBJECTMARK mark, typedef const char* FPDF_BYTESTRING key);
    [DllImport(DllName, EntryPoint = nameof(FPDFImageObj_LoadJpegFile), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFImageObj_LoadJpegFile(FPDF_PAGE* pages, int count, typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT image_object, FPDF_FILEACCESS* file_access);
    [DllImport(DllName, EntryPoint = nameof(FPDFImageObj_LoadJpegFileInline), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFImageObj_LoadJpegFileInline(FPDF_PAGE* pages, int count, typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT image_object, FPDF_FILEACCESS* file_access);
    [DllImport(DllName, EntryPoint = nameof(FPDFImageObj_SetMatrix), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFImageObj_SetMatrix(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT image_object, double a, double b, double c, double d, double e, double f);
    [DllImport(DllName, EntryPoint = nameof(FPDFImageObj_SetBitmap), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFImageObj_SetBitmap(FPDF_PAGE* pages, int count, typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT image_object, typedef fpdf_bitmap_t__* FPDF_BITMAP bitmap);
    [DllImport(DllName, EntryPoint = nameof(FPDFImageObj_GetBitmap), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFImageObj_GetBitmap(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT image_object);
    [DllImport(DllName, EntryPoint = nameof(FPDFImageObj_GetRenderedBitmap), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFImageObj_GetRenderedBitmap(typedef fpdf_document_t__* FPDF_DOCUMENT document, typedef fpdf_page_t__* FPDF_PAGE page, typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT image_object);
    [DllImport(DllName, EntryPoint = nameof(FPDFImageObj_GetImageDataDecoded), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFImageObj_GetImageDataDecoded(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT image_object, void* buffer, unsigned int buflen);
    [DllImport(DllName, EntryPoint = nameof(FPDFImageObj_GetImageDataRaw), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFImageObj_GetImageDataRaw(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT image_object, void* buffer, unsigned int buflen);
    [DllImport(DllName, EntryPoint = nameof(FPDFImageObj_GetImageFilterCount), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFImageObj_GetImageFilterCount(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT image_object);
    [DllImport(DllName, EntryPoint = nameof(FPDFImageObj_GetImageFilter), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFImageObj_GetImageFilter(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT image_object, int index, void* buffer, unsigned int buflen);
    [DllImport(DllName, EntryPoint = nameof(FPDFImageObj_GetImageMetadata), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFImageObj_GetImageMetadata(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT image_object, typedef fpdf_page_t__* FPDF_PAGE page, FPDF_IMAGEOBJ_METADATA* metadata);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObj_CreateNewPath), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObj_CreateNewPath(float x, float y);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObj_CreateNewRect), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObj_CreateNewRect(float x, float y, float w, float h);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObj_GetBounds), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObj_GetBounds(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT page_object, float* left, float* bottom, float* right, float* top);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObj_SetBlendMode), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObj_SetBlendMode(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT page_object, typedef const char* FPDF_BYTESTRING blend_mode);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObj_SetStrokeColor), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObj_SetStrokeColor(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT page_object, unsigned int R, unsigned int G, unsigned int B, unsigned int A);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObj_GetStrokeColor), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObj_GetStrokeColor(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT page_object, unsigned int* R, unsigned int* G, unsigned int* B, unsigned int* A);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObj_SetStrokeWidth), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObj_SetStrokeWidth(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT page_object, float width);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObj_GetStrokeWidth), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObj_GetStrokeWidth(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT page_object, float* width);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObj_GetLineJoin), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObj_GetLineJoin(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT page_object);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObj_SetLineJoin), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObj_SetLineJoin(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT page_object, int line_join);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObj_GetLineCap), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObj_GetLineCap(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT page_object);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObj_SetLineCap), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObj_SetLineCap(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT page_object, int line_cap);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObj_SetFillColor), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObj_SetFillColor(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT page_object, unsigned int R, unsigned int G, unsigned int B, unsigned int A);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObj_GetFillColor), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObj_GetFillColor(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT page_object, unsigned int* R, unsigned int* G, unsigned int* B, unsigned int* A);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObj_GetDashPhase), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObj_GetDashPhase(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT page_object, float* phase);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObj_SetDashPhase), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObj_SetDashPhase(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT page_object, float phase);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObj_GetDashCount), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObj_GetDashCount(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT page_object);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObj_GetDashArray), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObj_GetDashArray(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT page_object, float* dash_array, typedef unsigned long long size_t dash_count);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObj_SetDashArray), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObj_SetDashArray(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT page_object, const float* dash_array, typedef unsigned long long size_t dash_count, float phase);
    [DllImport(DllName, EntryPoint = nameof(FPDFPath_CountSegments), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPath_CountSegments(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT path);
    [DllImport(DllName, EntryPoint = nameof(FPDFPath_GetPathSegment), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPath_GetPathSegment(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT path, int index);
    [DllImport(DllName, EntryPoint = nameof(FPDFPathSegment_GetPoint), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPathSegment_GetPoint(typedef const fpdf_pathsegment_t* FPDF_PATHSEGMENT segment, float* x, float* y);
    [DllImport(DllName, EntryPoint = nameof(FPDFPathSegment_GetType), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPathSegment_GetType(typedef const fpdf_pathsegment_t* FPDF_PATHSEGMENT segment);
    [DllImport(DllName, EntryPoint = nameof(FPDFPathSegment_GetClose), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPathSegment_GetClose(typedef const fpdf_pathsegment_t* FPDF_PATHSEGMENT segment);
    [DllImport(DllName, EntryPoint = nameof(FPDFPath_MoveTo), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPath_MoveTo(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT path, float x, float y);
    [DllImport(DllName, EntryPoint = nameof(FPDFPath_LineTo), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPath_LineTo(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT path, float x, float y);
    [DllImport(DllName, EntryPoint = nameof(FPDFPath_BezierTo), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPath_BezierTo(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT path, float x1, float y1, float x2, float y2, float x3, float y3);
    [DllImport(DllName, EntryPoint = nameof(FPDFPath_Close), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPath_Close(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT path);
    [DllImport(DllName, EntryPoint = nameof(FPDFPath_SetDrawMode), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPath_SetDrawMode(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT path, int fillmode, typedef int FPDF_BOOL stroke);
    [DllImport(DllName, EntryPoint = nameof(FPDFPath_GetDrawMode), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPath_GetDrawMode(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT path, int* fillmode, FPDF_BOOL* stroke);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObj_NewTextObj), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObj_NewTextObj(typedef fpdf_document_t__* FPDF_DOCUMENT document, typedef const char* FPDF_BYTESTRING font, float font_size);
    [DllImport(DllName, EntryPoint = nameof(FPDFText_SetText), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFText_SetText(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT text_object, typedef const unsigned short* FPDF_WIDESTRING text);
    [DllImport(DllName, EntryPoint = nameof(FPDFText_SetCharcodes), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFText_SetCharcodes(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT text_object, const uint32_t* charcodes, typedef unsigned long long size_t count);
    [DllImport(DllName, EntryPoint = nameof(FPDFText_LoadFont), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFText_LoadFont(typedef fpdf_document_t__* FPDF_DOCUMENT document, const uint8_t* data, typedef unsigned int uint32_t size, int font_type, typedef int FPDF_BOOL cid);
    [DllImport(DllName, EntryPoint = nameof(FPDFText_LoadStandardFont), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFText_LoadStandardFont(typedef fpdf_document_t__* FPDF_DOCUMENT document, typedef const char* FPDF_BYTESTRING font);
    [DllImport(DllName, EntryPoint = nameof(FPDFTextObj_GetFontSize), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFTextObj_GetFontSize(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT text, float* size);
    [DllImport(DllName, EntryPoint = nameof(FPDFFont_Close), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFFont_Close(typedef fpdf_font_t__* FPDF_FONT font);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObj_CreateTextObj), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObj_CreateTextObj(typedef fpdf_document_t__* FPDF_DOCUMENT document, typedef fpdf_font_t__* FPDF_FONT font, float font_size);
    [DllImport(DllName, EntryPoint = nameof(FPDFTextObj_GetTextRenderMode), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFTextObj_GetTextRenderMode(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT text);
    [DllImport(DllName, EntryPoint = nameof(FPDFTextObj_SetTextRenderMode), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFTextObj_SetTextRenderMode(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT text, enum FPDF_TEXT_RENDERMODE {...} render_mode);
    [DllImport(DllName, EntryPoint = nameof(FPDFTextObj_GetText), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFTextObj_GetText(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT text_object, typedef fpdf_textpage_t__* FPDF_TEXTPAGE text_page, FPDF_WCHAR* buffer, unsigned int length);
    [DllImport(DllName, EntryPoint = nameof(FPDFTextObj_GetFont), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFTextObj_GetFont(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT text);
    [DllImport(DllName, EntryPoint = nameof(FPDFFont_GetFontName), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFFont_GetFontName(typedef fpdf_font_t__* FPDF_FONT font, char* buffer, unsigned int length);
    [DllImport(DllName, EntryPoint = nameof(FPDFFont_GetFlags), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFFont_GetFlags(typedef fpdf_font_t__* FPDF_FONT font);
    [DllImport(DllName, EntryPoint = nameof(FPDFFont_GetWeight), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFFont_GetWeight(typedef fpdf_font_t__* FPDF_FONT font);
    [DllImport(DllName, EntryPoint = nameof(FPDFFont_GetItalicAngle), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFFont_GetItalicAngle(typedef fpdf_font_t__* FPDF_FONT font, int* angle);
    [DllImport(DllName, EntryPoint = nameof(FPDFFont_GetAscent), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFFont_GetAscent(typedef fpdf_font_t__* FPDF_FONT font, float font_size, float* ascent);
    [DllImport(DllName, EntryPoint = nameof(FPDFFont_GetDescent), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFFont_GetDescent(typedef fpdf_font_t__* FPDF_FONT font, float font_size, float* descent);
    [DllImport(DllName, EntryPoint = nameof(FPDFFont_GetGlyphWidth), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFFont_GetGlyphWidth(typedef fpdf_font_t__* FPDF_FONT font, typedef unsigned int uint32_t glyph, float font_size, float* width);
    [DllImport(DllName, EntryPoint = nameof(FPDFFont_GetGlyphPath), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFFont_GetGlyphPath(typedef fpdf_font_t__* FPDF_FONT font, typedef unsigned int uint32_t glyph, float font_size);
    [DllImport(DllName, EntryPoint = nameof(FPDFGlyphPath_CountGlyphSegments), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFGlyphPath_CountGlyphSegments(typedef const fpdf_glyphpath_t__* FPDF_GLYPHPATH glyphpath);
    [DllImport(DllName, EntryPoint = nameof(FPDFGlyphPath_GetGlyphPathSegment), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFGlyphPath_GetGlyphPathSegment(typedef const fpdf_glyphpath_t__* FPDF_GLYPHPATH glyphpath, int index);
    [DllImport(DllName, EntryPoint = nameof(FPDFFormObj_CountObjects), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFFormObj_CountObjects(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT form_object);
    [DllImport(DllName, EntryPoint = nameof(FPDFFormObj_GetObject), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFFormObj_GetObject(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT form_object, unsigned int index);
    [DllImport(DllName, EntryPoint = nameof(FSDK_SetUnSpObjProcessHandler), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FSDK_SetUnSpObjProcessHandler(UNSUPPORT_INFO* unsp_info);
    [DllImport(DllName, EntryPoint = nameof(FSDK_SetTimeFunction), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FSDK_SetTimeFunction(time_t (*)(time_t (*)()* func)* func);
    [DllImport(DllName, EntryPoint = nameof(FSDK_SetLocaltimeFunction), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FSDK_SetLocaltimeFunction(tm* (*)(tm* (*)(const time_t*)* func)* func);
    [DllImport(DllName, EntryPoint = nameof(FPDFDoc_GetPageMode), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFDoc_GetPageMode(typedef fpdf_document_t__* FPDF_DOCUMENT document);
    [DllImport(DllName, EntryPoint = nameof(FPDFPage_Flatten), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPage_Flatten(typedef fpdf_page_t__* FPDF_PAGE page, int nFlag);
    [DllImport(DllName, EntryPoint = nameof(FPDF_ImportPagesByIndex), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_ImportPagesByIndex(typedef fpdf_document_t__* FPDF_DOCUMENT dest_doc, typedef fpdf_document_t__* FPDF_DOCUMENT src_doc, const int* page_indices, unsigned int length, int index);
    [DllImport(DllName, EntryPoint = nameof(FPDF_ImportPages), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_ImportPages(typedef fpdf_document_t__* FPDF_DOCUMENT dest_doc, typedef fpdf_document_t__* FPDF_DOCUMENT src_doc, typedef const char* FPDF_BYTESTRING pagerange, int index);
    ///<remarks>number of pages per page = num_pages_on_x_axis * num_pages_on_y_axis</remarks>
    ///<returns>A handle to the created document, or NULL on failure.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_ImportNPagesToOne), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_ImportNPagesToOne(typedef fpdf_document_t__* FPDF_DOCUMENT src_doc, float output_width, float output_height, typedef unsigned long long size_t num_pages_on_x_axis, typedef unsigned long long size_t num_pages_on_y_axis);
    [DllImport(DllName, EntryPoint = nameof(FPDF_NewXObjectFromPage), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_NewXObjectFromPage(typedef fpdf_document_t__* FPDF_DOCUMENT dest_doc, typedef fpdf_document_t__* FPDF_DOCUMENT src_doc, int src_page_index);
    [DllImport(DllName, EntryPoint = nameof(FPDF_CloseXObject), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_CloseXObject(typedef fpdf_xobject_t__* FPDF_XOBJECT xobject);
    [DllImport(DllName, EntryPoint = nameof(FPDF_NewFormObjectFromXObject), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_NewFormObjectFromXObject(typedef fpdf_xobject_t__* FPDF_XOBJECT xobject);
    [DllImport(DllName, EntryPoint = nameof(FPDF_CopyViewerPreferences), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_CopyViewerPreferences(typedef fpdf_document_t__* FPDF_DOCUMENT dest_doc, typedef fpdf_document_t__* FPDF_DOCUMENT src_doc);
    ///<summary>
    /// Start to render page contents to a device independent bitmap
    /// progressively with a specified color scheme for the content.
    ///</summary>
    ///<param name = "bitmap">
    /// Handle to the device independent bitmap (as the
    /// output buffer). Bitmap handle can be created by
    /// FPDFBitmap_Create function.
    ///</param>
    ///<param name = "page">
    /// Handle to the page as returned by FPDF_LoadPage
    /// function.
    ///</param>
    ///<param name = "start_x">
    /// Left pixel position of the display area in the
    /// bitmap coordinate.
    ///</param>
    ///<param name = "start_y">
    /// Top pixel position of the display area in the
    /// bitmap coordinate.
    ///</param>
    ///<param name = "size_x">
    /// Horizontal size (in pixels) for displaying the
    /// page.
    ///</param>
    ///<param name = "size_y">Vertical size (in pixels) for displaying the page.</param>
    ///<param name = "rotate">
    /// Page orientation: 0 (normal), 1 (rotated 90
    /// degrees clockwise), 2 (rotated 180 degrees),
    /// 3 (rotated 90 degrees counter-clockwise).
    ///</param>
    ///<param name = "flags">
    /// 0 for normal display, or combination of flags
    /// defined in fpdfview.h. With FPDF_ANNOT flag, it
    /// renders all annotations that does not require
    /// user-interaction, which are all annotations except
    /// widget and popup annotations.
    ///</param>
    ///<param name = "color_scheme">
    /// Color scheme to be used in rendering the |page|.
    /// If null, this function will work similar to
    /// FPDF_RenderPageBitmap_Start().
    ///</param>
    ///<param name = "pause">
    /// The IFSDK_PAUSE interface. A callback mechanism
    /// allowing the page rendering process.
    ///</param>
    ///<returns>
    /// Rendering Status. See flags for progressive process status for the
    /// details.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_RenderPageBitmapWithColorScheme_Start), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_RenderPageBitmapWithColorScheme_Start(typedef fpdf_bitmap_t__* FPDF_BITMAP bitmap, typedef fpdf_page_t__* FPDF_PAGE page, int start_x, int start_y, int size_x, int size_y, int rotate, int flags, const FPDF_COLORSCHEME* color_scheme, IFSDK_PAUSE* pause);
    ///<summary>
    /// Start to render page contents to a device independent bitmap
    /// progressively.
    ///</summary>
    ///<param name = "bitmap">
    /// Handle to the device independent bitmap (as the
    /// output buffer). Bitmap handle can be created by
    /// FPDFBitmap_Create().
    ///</param>
    ///<param name = "page">Handle to the page, as returned by FPDF_LoadPage().</param>
    ///<param name = "start_x">
    /// Left pixel position of the display area in the
    /// bitmap coordinates.
    ///</param>
    ///<param name = "start_y">
    /// Top pixel position of the display area in the bitmap
    /// coordinates.
    ///</param>
    ///<param name = "size_x">Horizontal size (in pixels) for displaying the page.</param>
    ///<param name = "size_y">Vertical size (in pixels) for displaying the page.</param>
    ///<param name = "rotate">
    /// Page orientation: 0 (normal), 1 (rotated 90 degrees
    /// clockwise), 2 (rotated 180 degrees), 3 (rotated 90
    /// degrees counter-clockwise).
    ///</param>
    ///<param name = "flags">
    /// 0 for normal display, or combination of flags
    /// defined in fpdfview.h. With FPDF_ANNOT flag, it
    /// renders all annotations that does not require
    /// user-interaction, which are all annotations except
    /// widget and popup annotations.
    ///</param>
    ///<param name = "pause">
    /// The IFSDK_PAUSE interface.A callback mechanism
    /// allowing the page rendering process
    ///</param>
    ///<returns>
    /// Rendering Status. See flags for progressive process status for the
    /// details.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_RenderPageBitmap_Start), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_RenderPageBitmap_Start(typedef fpdf_bitmap_t__* FPDF_BITMAP bitmap, typedef fpdf_page_t__* FPDF_PAGE page, int start_x, int start_y, int size_x, int size_y, int rotate, int flags, IFSDK_PAUSE* pause);
    ///<summary>Continue rendering a PDF page.</summary>
    ///<param name = "page">Handle to the page, as returned by FPDF_LoadPage().</param>
    ///<param name = "pause">
    /// The IFSDK_PAUSE interface (a callback mechanism
    /// allowing the page rendering process to be paused
    /// before it's finished). This can be NULL if you
    /// don't want to pause.
    ///</param>
    ///<returns>
    /// The rendering status. See flags for progressive process status for
    /// the details.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_RenderPage_Continue), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_RenderPage_Continue(typedef fpdf_page_t__* FPDF_PAGE page, IFSDK_PAUSE* pause);
    ///<summary>
    /// Release the resource allocate during page rendering. Need to be
    /// called after finishing rendering or
    /// cancel the rendering.
    ///</summary>
    ///<param name = "page">Handle to the page, as returned by FPDF_LoadPage().</param>
    [DllImport(DllName, EntryPoint = nameof(FPDF_RenderPage_Close), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_RenderPage_Close(typedef fpdf_page_t__* FPDF_PAGE page);
    ///<summary>Saves the copy of specified document in custom way.</summary>
    ///<param name = "document">
    /// Handle to document, as returned by
    /// FPDF_LoadDocument() or FPDF_CreateNewDocument().
    ///</param>
    ///<param name = "pFileWrite">A pointer to a custom file write structure.</param>
    ///<param name = "flags">The creating flags.</param>
    ///<returns>TRUE for succeed, FALSE for failed.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_SaveAsCopy), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_SaveAsCopy(typedef fpdf_document_t__* FPDF_DOCUMENT document, FPDF_FILEWRITE* pFileWrite, typedef unsigned int FPDF_DWORD flags);
    ///<summary>
    /// Same as FPDF_SaveAsCopy(), except the file version of the
    /// saved document can be specified by the caller.
    ///</summary>
    ///<param name = "document">Handle to document.</param>
    ///<param name = "pFileWrite">A pointer to a custom file write structure.</param>
    ///<param name = "flags">The creating flags.</param>
    ///<param name = "fileVersion">
    /// The PDF file version. File version: 14 for 1.4,
    /// 15 for 1.5, ...
    ///</param>
    ///<returns>TRUE if succeed, FALSE if failed.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_SaveWithVersion), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_SaveWithVersion(typedef fpdf_document_t__* FPDF_DOCUMENT document, FPDF_FILEWRITE* pFileWrite, typedef unsigned int FPDF_DWORD flags, int fileVersion);
    [DllImport(DllName, EntryPoint = nameof(FPDFText_GetCharIndexFromTextIndex), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFText_GetCharIndexFromTextIndex(typedef fpdf_textpage_t__* FPDF_TEXTPAGE text_page, int nTextIndex);
    [DllImport(DllName, EntryPoint = nameof(FPDFText_GetTextIndexFromCharIndex), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFText_GetTextIndexFromCharIndex(typedef fpdf_textpage_t__* FPDF_TEXTPAGE text_page, int nCharIndex);
    ///<summary>Get the structure tree for a page.</summary>
    ///<param name = "page">Handle to the page, as returned by FPDF_LoadPage().</param>
    ///<returns>A handle to the structure tree or NULL on error.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_StructTree_GetForPage), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_StructTree_GetForPage(typedef fpdf_page_t__* FPDF_PAGE page);
    ///<summary>Release a resource allocated by FPDF_StructTree_GetForPage().</summary>
    ///<param name = "struct_tree">
    /// Handle to the structure tree, as returned by
    /// FPDF_StructTree_LoadPage().
    ///</param>
    [DllImport(DllName, EntryPoint = nameof(FPDF_StructTree_Close), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_StructTree_Close(typedef fpdf_structtree_t__* FPDF_STRUCTTREE struct_tree);
    ///<summary>Count the number of children for the structure tree.</summary>
    ///<param name = "struct_tree">
    /// Handle to the structure tree, as returned by
    /// FPDF_StructTree_LoadPage().
    ///</param>
    ///<returns>The number of children, or -1 on error.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_StructTree_CountChildren), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_StructTree_CountChildren(typedef fpdf_structtree_t__* FPDF_STRUCTTREE struct_tree);
    ///<summary>Get a child in the structure tree.</summary>
    ///<param name = "struct_tree">
    /// Handle to the structure tree, as returned by
    /// FPDF_StructTree_LoadPage().
    ///</param>
    ///<param name = "index">The index for the child, 0-based.</param>
    ///<returns>The child at the n-th index or NULL on error.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_StructTree_GetChildAtIndex), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_StructTree_GetChildAtIndex(typedef fpdf_structtree_t__* FPDF_STRUCTTREE struct_tree, int index);
    ///<summary>Get the alt text for a given element.</summary>
    ///<param name = "struct_element">Handle to the struct element.</param>
    ///<param name = "buffer">A buffer for output the alt text. May be NULL.</param>
    ///<param name = "buflen">The length of the buffer, in bytes. May be 0.</param>
    ///<remarks>
    /// Regardless of the platform, the |buffer| is always in UTF-16LE
    /// encoding. The string is terminated by a UTF16 NUL character. If
    /// |buflen| is less than the required length, or |buffer| is NULL,
    /// |buffer| will not be modified.
    ///</remarks>
    ///<returns>
    /// The number of bytes in the title, including the terminating NUL
    /// character. The number of bytes is returned regardless of the
    /// |buffer| and |buflen| parameters.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_StructElement_GetAltText), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_StructElement_GetAltText(typedef fpdf_structelement_t__* FPDF_STRUCTELEMENT struct_element, void* buffer, unsigned int buflen);
    ///<summary>Get the ID for a given element.</summary>
    ///<param name = "struct_element">Handle to the struct element.</param>
    ///<param name = "buffer">A buffer for output the ID string. May be NULL.</param>
    ///<param name = "buflen">The length of the buffer, in bytes. May be 0.</param>
    ///<remarks>
    /// Regardless of the platform, the |buffer| is always in UTF-16LE
    /// encoding. The string is terminated by a UTF16 NUL character. If
    /// |buflen| is less than the required length, or |buffer| is NULL,
    /// |buffer| will not be modified.
    ///</remarks>
    ///<returns>
    /// The number of bytes in the ID string, including the terminating NUL
    /// character. The number of bytes is returned regardless of the
    /// |buffer| and |buflen| parameters.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_StructElement_GetID), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_StructElement_GetID(typedef fpdf_structelement_t__* FPDF_STRUCTELEMENT struct_element, void* buffer, unsigned int buflen);
    ///<summary>Get the case-insensitive IETF BCP 47 language code for an element.</summary>
    ///<param name = "struct_element">Handle to the struct element.</param>
    ///<param name = "buffer">A buffer for output the lang string. May be NULL.</param>
    ///<param name = "buflen">The length of the buffer, in bytes. May be 0.</param>
    ///<remarks>
    /// Regardless of the platform, the |buffer| is always in UTF-16LE
    /// encoding. The string is terminated by a UTF16 NUL character. If
    /// |buflen| is less than the required length, or |buffer| is NULL,
    /// |buffer| will not be modified.
    ///</remarks>
    ///<returns>
    /// The number of bytes in the ID string, including the terminating NUL
    /// character. The number of bytes is returned regardless of the
    /// |buffer| and |buflen| parameters.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_StructElement_GetLang), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_StructElement_GetLang(typedef fpdf_structelement_t__* FPDF_STRUCTELEMENT struct_element, void* buffer, unsigned int buflen);
    ///<summary>Get a struct element attribute of type "name" or "string".</summary>
    ///<param name = "struct_element">Handle to the struct element.</param>
    ///<param name = "attr_name">The name of the attribute to retrieve.</param>
    ///<param name = "buffer">A buffer for output. May be NULL.</param>
    ///<param name = "buflen">The length of the buffer, in bytes. May be 0.</param>
    ///<remarks>
    /// Regardless of the platform, the |buffer| is always in UTF-16LE
    /// encoding. The string is terminated by a UTF16 NUL character. If
    /// |buflen| is less than the required length, or |buffer| is NULL,
    /// |buffer| will not be modified.
    ///</remarks>
    ///<returns>
    /// The number of bytes in the attribute value, including the
    /// terminating NUL character. The number of bytes is returned
    /// regardless of the |buffer| and |buflen| parameters.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_StructElement_GetStringAttribute), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_StructElement_GetStringAttribute(typedef fpdf_structelement_t__* FPDF_STRUCTELEMENT struct_element, typedef const char* FPDF_BYTESTRING attr_name, void* buffer, unsigned int buflen);
    ///<summary>Get the marked content ID for a given element.</summary>
    ///<param name = "struct_element">Handle to the struct element.</param>
    ///<returns>
    /// The marked content ID of the element. If no ID exists, returns
    /// -1.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_StructElement_GetMarkedContentID), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_StructElement_GetMarkedContentID(typedef fpdf_structelement_t__* FPDF_STRUCTELEMENT struct_element);
    ///<summary>Get the type (/S) for a given element.</summary>
    ///<param name = "struct_element">Handle to the struct element.</param>
    ///<param name = "buffer">A buffer for output. May be NULL.</param>
    ///<param name = "buflen">The length of the buffer, in bytes. May be 0.</param>
    ///<remarks>
    /// Regardless of the platform, the |buffer| is always in UTF-16LE
    /// encoding. The string is terminated by a UTF16 NUL character. If
    /// |buflen| is less than the required length, or |buffer| is NULL,
    /// |buffer| will not be modified.
    ///</remarks>
    ///<returns>
    /// The number of bytes in the type, including the terminating NUL
    /// character. The number of bytes is returned regardless of the
    /// |buffer| and |buflen| parameters.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_StructElement_GetType), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_StructElement_GetType(typedef fpdf_structelement_t__* FPDF_STRUCTELEMENT struct_element, void* buffer, unsigned int buflen);
    ///<summary>Get the title (/T) for a given element.</summary>
    ///<param name = "struct_element">Handle to the struct element.</param>
    ///<param name = "buffer">A buffer for output. May be NULL.</param>
    ///<param name = "buflen">The length of the buffer, in bytes. May be 0.</param>
    ///<remarks>
    /// Regardless of the platform, the |buffer| is always in UTF-16LE
    /// encoding. The string is terminated by a UTF16 NUL character. If
    /// |buflen| is less than the required length, or |buffer| is NULL,
    /// |buffer| will not be modified.
    ///</remarks>
    ///<returns>
    /// The number of bytes in the title, including the terminating NUL
    /// character. The number of bytes is returned regardless of the
    /// |buffer| and |buflen| parameters.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_StructElement_GetTitle), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_StructElement_GetTitle(typedef fpdf_structelement_t__* FPDF_STRUCTELEMENT struct_element, void* buffer, unsigned int buflen);
    ///<summary>Count the number of children for the structure element.</summary>
    ///<param name = "struct_element">Handle to the struct element.</param>
    ///<returns>The number of children, or -1 on error.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_StructElement_CountChildren), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_StructElement_CountChildren(typedef fpdf_structelement_t__* FPDF_STRUCTELEMENT struct_element);
    ///<summary>Get a child in the structure element.</summary>
    ///<param name = "struct_tree">Handle to the struct element.</param>
    ///<param name = "index">The index for the child, 0-based.</param>
    ///<remarks>
    /// If the child exists but is not an element, then this function will
    /// return NULL. This will also return NULL for out of bounds indices.
    ///</remarks>
    ///<returns>The child at the n-th index or NULL on error.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDF_StructElement_GetChildAtIndex), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_StructElement_GetChildAtIndex(typedef fpdf_structelement_t__* FPDF_STRUCTELEMENT struct_element, int index);
    ///<summary>Prepare information about all characters in a page.</summary>
    ///<param name = "page">
    /// Handle to the page. Returned by FPDF_LoadPage function
    /// (in FPDFVIEW module).
    ///</param>
    ///<remarks>
    /// Application must call FPDFText_ClosePage to release the text page
    /// information.
    ///</remarks>
    ///<returns>
    /// A handle to the text page information structure.
    /// NULL if something goes wrong.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFText_LoadPage), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFText_LoadPage(typedef fpdf_page_t__* FPDF_PAGE page);
    ///<summary>
    /// Release all resources allocated for a text page information
    /// structure.
    ///</summary>
    ///<param name = "text_page">
    /// Handle to a text page information structure.
    /// Returned by FPDFText_LoadPage function.
    ///</param>
    [DllImport(DllName, EntryPoint = nameof(FPDFText_ClosePage), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFText_ClosePage(typedef fpdf_textpage_t__* FPDF_TEXTPAGE text_page);
    ///<summary>Get number of characters in a page.</summary>
    ///<param name = "text_page">
    /// Handle to a text page information structure.
    /// Returned by FPDFText_LoadPage function.
    ///</param>
    ///<remarks>
    /// Characters in a page form a "stream", inside the stream, each
    /// character has an index.
    /// We will use the index parameters in many of FPDFTEXT functions. The
    /// first character in the page
    /// has an index value of zero.
    ///</remarks>
    ///<returns>
    /// Number of characters in the page. Return -1 for error.
    /// Generated characters, like additional space characters, new line
    /// characters, are also counted.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFText_CountChars), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFText_CountChars(typedef fpdf_textpage_t__* FPDF_TEXTPAGE text_page);
    ///<summary>Get Unicode of a character in a page.</summary>
    ///<param name = "text_page">
    /// Handle to a text page information structure.
    /// Returned by FPDFText_LoadPage function.
    ///</param>
    ///<param name = "index">Zero-based index of the character.</param>
    ///<returns>
    /// The Unicode of the particular character.
    /// If a character is not encoded in Unicode and Foxit engine can't
    /// convert to Unicode,
    /// the return value will be zero.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFText_GetUnicode), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFText_GetUnicode(typedef fpdf_textpage_t__* FPDF_TEXTPAGE text_page, int index);
    ///<summary>Get the font size of a particular character.</summary>
    ///<param name = "text_page">
    /// Handle to a text page information structure.
    /// Returned by FPDFText_LoadPage function.
    ///</param>
    ///<param name = "index">Zero-based index of the character.</param>
    ///<returns>
    /// The font size of the particular character, measured in points (about
    /// 1/72 inch). This is the typographic size of the font (so called
    /// "em size").
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFText_GetFontSize), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFText_GetFontSize(typedef fpdf_textpage_t__* FPDF_TEXTPAGE text_page, int index);
    ///<summary>Get the font name and flags of a particular character.</summary>
    ///<param name = "text_page">
    /// Handle to a text page information structure.
    /// Returned by FPDFText_LoadPage function.
    ///</param>
    ///<param name = "index">Zero-based index of the character.</param>
    ///<param name = "buffer">A buffer receiving the font name.</param>
    ///<param name = "buflen">The length of |buffer| in bytes.</param>
    ///<param name = "flags">
    /// Optional pointer to an int receiving the font flags.
    /// These flags should be interpreted per PDF spec 1.7
    /// Section 5.7.1 Font Descriptor Flags.
    ///</param>
    ///<returns>
    /// On success, return the length of the font name, including the
    /// trailing NUL character, in bytes. If this length is less than or
    /// equal to |length|, |buffer| is set to the font name, |flags| is
    /// set to the font flags. |buffer| is in UTF-8 encoding. Return 0 on
    /// failure.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFText_GetFontInfo), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFText_GetFontInfo(typedef fpdf_textpage_t__* FPDF_TEXTPAGE text_page, int index, void* buffer, unsigned int buflen, int* flags);
    ///<summary>Get the font weight of a particular character.</summary>
    ///<param name = "text_page">
    /// Handle to a text page information structure.
    /// Returned by FPDFText_LoadPage function.
    ///</param>
    ///<param name = "index">Zero-based index of the character.</param>
    ///<returns>
    /// On success, return the font weight of the particular character. If
    /// |text_page| is invalid, if |index| is out of bounds, or if the
    /// character's text object is undefined, return -1.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFText_GetFontWeight), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFText_GetFontWeight(typedef fpdf_textpage_t__* FPDF_TEXTPAGE text_page, int index);
    ///<summary>Get text rendering mode of character.</summary>
    ///<param name = "text_page">
    /// Handle to a text page information structure.
    /// Returned by FPDFText_LoadPage function.
    ///</param>
    ///<param name = "index">Zero-based index of the character.</param>
    ///<returns>
    /// On success, return the render mode value. A valid value is of type
    /// FPDF_TEXT_RENDERMODE. If |text_page| is invalid, if |index| is out
    /// of bounds, or if the text object is undefined, then return
    /// FPDF_TEXTRENDERMODE_UNKNOWN.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFText_GetTextRenderMode), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFText_GetTextRenderMode(typedef fpdf_textpage_t__* FPDF_TEXTPAGE text_page, int index);
    ///<summary>Get the fill color of a particular character.</summary>
    ///<param name = "text_page">
    /// Handle to a text page information structure.
    /// Returned by FPDFText_LoadPage function.
    ///</param>
    ///<param name = "index">Zero-based index of the character.</param>
    ///<param name = "R">
    /// Pointer to an unsigned int number receiving the
    /// red value of the fill color.
    ///</param>
    ///<param name = "G">
    /// Pointer to an unsigned int number receiving the
    /// green value of the fill color.
    ///</param>
    ///<param name = "B">
    /// Pointer to an unsigned int number receiving the
    /// blue value of the fill color.
    ///</param>
    ///<param name = "A">
    /// Pointer to an unsigned int number receiving the
    /// alpha value of the fill color.
    ///</param>
    ///<returns>
    /// Whether the call succeeded. If false, |R|, |G|, |B| and |A| are
    /// unchanged.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFText_GetFillColor), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFText_GetFillColor(typedef fpdf_textpage_t__* FPDF_TEXTPAGE text_page, int index, unsigned int* R, unsigned int* G, unsigned int* B, unsigned int* A);
    ///<summary>Get the stroke color of a particular character.</summary>
    ///<param name = "text_page">
    /// Handle to a text page information structure.
    /// Returned by FPDFText_LoadPage function.
    ///</param>
    ///<param name = "index">Zero-based index of the character.</param>
    ///<param name = "R">
    /// Pointer to an unsigned int number receiving the
    /// red value of the stroke color.
    ///</param>
    ///<param name = "G">
    /// Pointer to an unsigned int number receiving the
    /// green value of the stroke color.
    ///</param>
    ///<param name = "B">
    /// Pointer to an unsigned int number receiving the
    /// blue value of the stroke color.
    ///</param>
    ///<param name = "A">
    /// Pointer to an unsigned int number receiving the
    /// alpha value of the stroke color.
    ///</param>
    ///<returns>
    /// Whether the call succeeded. If false, |R|, |G|, |B| and |A| are
    /// unchanged.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFText_GetStrokeColor), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFText_GetStrokeColor(typedef fpdf_textpage_t__* FPDF_TEXTPAGE text_page, int index, unsigned int* R, unsigned int* G, unsigned int* B, unsigned int* A);
    ///<summary>Get character rotation angle.</summary>
    ///<param name = "text_page">
    /// Handle to a text page information structure.
    /// Returned by FPDFText_LoadPage function.
    ///</param>
    ///<param name = "index">Zero-based index of the character.</param>
    ///<returns>
    /// On success, return the angle value in radian. Value will always be
    /// greater or equal to 0. If |text_page| is invalid, or if |index| is
    /// out of bounds, then return -1.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFText_GetCharAngle), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFText_GetCharAngle(typedef fpdf_textpage_t__* FPDF_TEXTPAGE text_page, int index);
    ///<summary>Get bounding box of a particular character.</summary>
    ///<param name = "text_page">
    /// Handle to a text page information structure.
    /// Returned by FPDFText_LoadPage function.
    ///</param>
    ///<param name = "index">Zero-based index of the character.</param>
    ///<param name = "left">
    /// Pointer to a double number receiving left position
    /// of the character box.
    ///</param>
    ///<param name = "right">
    /// Pointer to a double number receiving right position
    /// of the character box.
    ///</param>
    ///<param name = "bottom">
    /// Pointer to a double number receiving bottom position
    /// of the character box.
    ///</param>
    ///<param name = "top">
    /// Pointer to a double number receiving top position of
    /// the character box.
    ///</param>
    ///<remarks>All positions are measured in PDF "user space".</remarks>
    ///<returns>
    /// On success, return TRUE and fill in |left|, |right|, |bottom|, and
    /// |top|. If |text_page| is invalid, or if |index| is out of bounds,
    /// then return FALSE, and the out parameters remain unmodified.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFText_GetCharBox), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFText_GetCharBox(typedef fpdf_textpage_t__* FPDF_TEXTPAGE text_page, int index, double* left, double* right, double* bottom, double* top);
    ///<summary>
    /// Get a "loose" bounding box of a particular character, i.e., covering
    /// the entire glyph bounds, without taking the actual glyph shape into
    /// account.
    ///</summary>
    ///<param name = "text_page">
    /// Handle to a text page information structure.
    /// Returned by FPDFText_LoadPage function.
    ///</param>
    ///<param name = "index">Zero-based index of the character.</param>
    ///<param name = "rect">Pointer to a FS_RECTF receiving the character box.</param>
    ///<remarks>All positions are measured in PDF "user space".</remarks>
    ///<returns>
    /// On success, return TRUE and fill in |rect|. If |text_page| is
    /// invalid, or if |index| is out of bounds, then return FALSE, and the
    /// |rect| out parameter remains unmodified.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFText_GetLooseCharBox), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFText_GetLooseCharBox(typedef fpdf_textpage_t__* FPDF_TEXTPAGE text_page, int index, FS_RECTF* rect);
    ///<summary>Get the effective transformation matrix for a particular character.</summary>
    ///<param name = "text_page">
    /// Handle to a text page information structure.
    /// Returned by FPDFText_LoadPage().
    ///</param>
    ///<param name = "index">Zero-based index of the character.</param>
    ///<param name = "matrix">
    /// Pointer to a FS_MATRIX receiving the transformation
    /// matrix.
    ///</param>
    ///<returns>
    /// On success, return TRUE and fill in |matrix|. If |text_page| is
    /// invalid, or if |index| is out of bounds, or if |matrix| is NULL,
    /// then return FALSE, and |matrix| remains unmodified.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFText_GetMatrix), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFText_GetMatrix(typedef fpdf_textpage_t__* FPDF_TEXTPAGE text_page, int index, FS_MATRIX* matrix);
    ///<summary>Get origin of a particular character.</summary>
    ///<param name = "text_page">
    /// Handle to a text page information structure.
    /// Returned by FPDFText_LoadPage function.
    ///</param>
    ///<param name = "index">Zero-based index of the character.</param>
    ///<param name = "x">
    /// Pointer to a double number receiving x coordinate of
    /// the character origin.
    ///</param>
    ///<param name = "y">
    /// Pointer to a double number receiving y coordinate of
    /// the character origin.
    ///</param>
    ///<remarks>All positions are measured in PDF "user space".</remarks>
    ///<returns>Whether the call succeeded. If false, x and y are unchanged.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFText_GetCharOrigin), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFText_GetCharOrigin(typedef fpdf_textpage_t__* FPDF_TEXTPAGE text_page, int index, double* x, double* y);
    ///<summary>
    /// Get the index of a character at or nearby a certain position on the
    /// page.
    ///</summary>
    ///<param name = "text_page">
    /// Handle to a text page information structure.
    /// Returned by FPDFText_LoadPage function.
    ///</param>
    ///<param name = "x">X position in PDF "user space".</param>
    ///<param name = "y">Y position in PDF "user space".</param>
    ///<param name = "xTolerance">
    /// An x-axis tolerance value for character hit
    /// detection, in point units.
    ///</param>
    ///<param name = "yTolerance">
    /// A y-axis tolerance value for character hit
    /// detection, in point units.
    ///</param>
    ///<returns>
    /// The zero-based index of the character at, or nearby the point (x,y).
    /// If there is no character at or nearby the point, return value will
    /// be -1. If an error occurs, -3 will be returned.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFText_GetCharIndexAtPos), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFText_GetCharIndexAtPos(typedef fpdf_textpage_t__* FPDF_TEXTPAGE text_page, double x, double y, double xTolerance, double yTolerance);
    ///<summary>Extract unicode text string from the page.</summary>
    ///<param name = "text_page">
    /// Handle to a text page information structure.
    /// Returned by FPDFText_LoadPage function.
    ///</param>
    ///<param name = "start_index">Index for the start characters.</param>
    ///<param name = "count">Number of characters to be extracted.</param>
    ///<param name = "result">
    /// A buffer (allocated by application) receiving the
    /// extracted unicodes. The size of the buffer must be
    /// able to hold the number of characters plus a
    /// terminator.
    ///</param>
    ///<remarks>This function ignores characters without unicode information.</remarks>
    ///<returns>
    /// Number of characters written into the result buffer, including the
    /// trailing terminator.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFText_GetText), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFText_GetText(typedef fpdf_textpage_t__* FPDF_TEXTPAGE text_page, int start_index, int count, unsigned short* result);
    ///<summary>Count number of rectangular areas occupied by a segment of texts.</summary>
    ///<param name = "text_page">
    /// Handle to a text page information structure.
    /// Returned by FPDFText_LoadPage function.
    ///</param>
    ///<param name = "start_index">Index for the start characters.</param>
    ///<param name = "count">Number of characters.</param>
    ///<remarks>
    /// This function, along with FPDFText_GetRect can be used by
    /// applications to detect the position on the page for a text segment,
    /// so proper areas can be highlighted. FPDFTEXT will automatically
    /// merge small character boxes into bigger one if those characters
    /// are on the same line and use same font settings.
    ///</remarks>
    ///<returns>Number of rectangles. Zero for error.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFText_CountRects), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFText_CountRects(typedef fpdf_textpage_t__* FPDF_TEXTPAGE text_page, int start_index, int count);
    ///<summary>
    /// Get a rectangular area from the result generated by
    /// FPDFText_CountRects.
    ///</summary>
    ///<param name = "text_page">
    /// Handle to a text page information structure.
    /// Returned by FPDFText_LoadPage function.
    ///</param>
    ///<param name = "rect_index">Zero-based index for the rectangle.</param>
    ///<param name = "left">
    /// Pointer to a double value receiving the rectangle
    /// left boundary.
    ///</param>
    ///<param name = "top">
    /// Pointer to a double value receiving the rectangle
    /// top boundary.
    ///</param>
    ///<param name = "right">
    /// Pointer to a double value receiving the rectangle
    /// right boundary.
    ///</param>
    ///<param name = "bottom">
    /// Pointer to a double value receiving the rectangle
    /// bottom boundary.
    ///</param>
    ///<returns>
    /// On success, return TRUE and fill in |left|, |top|, |right|, and
    /// |bottom|. If |text_page| is invalid then return FALSE, and the out
    /// parameters remain unmodified. If |text_page| is valid but
    /// |rect_index| is out of bounds, then return FALSE and set the out
    /// parameters to 0.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFText_GetRect), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFText_GetRect(typedef fpdf_textpage_t__* FPDF_TEXTPAGE text_page, int rect_index, double* left, double* top, double* right, double* bottom);
    ///<summary>Extract unicode text within a rectangular boundary on the page.</summary>
    ///<param name = "text_page">
    /// Handle to a text page information structure.
    /// Returned by FPDFText_LoadPage function.
    ///</param>
    ///<param name = "left">Left boundary.</param>
    ///<param name = "top">Top boundary.</param>
    ///<param name = "right">Right boundary.</param>
    ///<param name = "bottom">Bottom boundary.</param>
    ///<param name = "buffer">A unicode buffer.</param>
    ///<param name = "buflen">
    /// Number of characters (not bytes) for the buffer,
    /// excluding an additional terminator.
    ///</param>
    ///<returns>
    /// If buffer is NULL or buflen is zero, return number of characters
    /// (not bytes) of text present within the rectangle, excluding a
    /// terminating NUL. Generally you should pass a buffer at least one
    /// larger than this if you want a terminating NUL, which will be
    /// provided if space is available. Otherwise, return number of
    /// characters copied into the buffer, including the terminating NUL
    /// when space for it is available.
    /// Comment:
    /// If the buffer is too small, as much text as will fit is copied into
    /// it.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFText_GetBoundedText), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFText_GetBoundedText(typedef fpdf_textpage_t__* FPDF_TEXTPAGE text_page, double left, double top, double right, double bottom, unsigned short* buffer, int buflen);
    ///<summary>Start a search.</summary>
    ///<param name = "text_page">
    /// Handle to a text page information structure.
    /// Returned by FPDFText_LoadPage function.
    ///</param>
    ///<param name = "findwhat">A unicode match pattern.</param>
    ///<param name = "flags">Option flags.</param>
    ///<param name = "start_index">Start from this character. -1 for end of the page.</param>
    ///<returns>
    /// A handle for the search context. FPDFText_FindClose must be called
    /// to release this handle.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFText_FindStart), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFText_FindStart(typedef fpdf_textpage_t__* FPDF_TEXTPAGE text_page, typedef const unsigned short* FPDF_WIDESTRING findwhat, unsigned int flags, int start_index);
    ///<summary>Search in the direction from page start to end.</summary>
    ///<param name = "handle">
    /// A search context handle returned by
    /// FPDFText_FindStart.
    ///</param>
    ///<returns>Whether a match is found.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFText_FindNext), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFText_FindNext(typedef fpdf_schhandle_t__* FPDF_SCHHANDLE handle);
    ///<summary>Search in the direction from page end to start.</summary>
    ///<param name = "handle">
    /// A search context handle returned by
    /// FPDFText_FindStart.
    ///</param>
    ///<returns>Whether a match is found.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFText_FindPrev), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFText_FindPrev(typedef fpdf_schhandle_t__* FPDF_SCHHANDLE handle);
    ///<summary>Get the starting character index of the search result.</summary>
    ///<param name = "handle">
    /// A search context handle returned by
    /// FPDFText_FindStart.
    ///</param>
    ///<returns>Index for the starting character.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFText_GetSchResultIndex), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFText_GetSchResultIndex(typedef fpdf_schhandle_t__* FPDF_SCHHANDLE handle);
    ///<summary>Get the number of matched characters in the search result.</summary>
    ///<param name = "handle">
    /// A search context handle returned by
    /// FPDFText_FindStart.
    ///</param>
    ///<returns>Number of matched characters.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFText_GetSchCount), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFText_GetSchCount(typedef fpdf_schhandle_t__* FPDF_SCHHANDLE handle);
    ///<summary>Release a search context.</summary>
    ///<param name = "handle">
    /// A search context handle returned by
    /// FPDFText_FindStart.
    ///</param>
    [DllImport(DllName, EntryPoint = nameof(FPDFText_FindClose), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFText_FindClose(typedef fpdf_schhandle_t__* FPDF_SCHHANDLE handle);
    ///<summary>Prepare information about weblinks in a page.</summary>
    ///<param name = "text_page">
    /// Handle to a text page information structure.
    /// Returned by FPDFText_LoadPage function.
    ///</param>
    ///<remarks>
    /// Weblinks are those links implicitly embedded in PDF pages. PDF also
    /// has a type of annotation called "link" (FPDFTEXT doesn't deal with
    /// that kind of link). FPDFTEXT weblink feature is useful for
    /// automatically detecting links in the page contents. For example,
    /// things like "https://www.example.com" will be detected, so
    /// applications can allow user to click on those characters to activate
    /// the link, even the PDF doesn't come with link annotations.
    /// FPDFLink_CloseWebLinks must be called to release resources.
    ///</remarks>
    ///<returns>
    /// A handle to the page's links information structure, or
    /// NULL if something goes wrong.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFLink_LoadWebLinks), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFLink_LoadWebLinks(typedef fpdf_textpage_t__* FPDF_TEXTPAGE text_page);
    ///<summary>Count number of detected web links.</summary>
    ///<param name = "link_page">Handle returned by FPDFLink_LoadWebLinks.</param>
    ///<returns>Number of detected web links.</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFLink_CountWebLinks), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFLink_CountWebLinks(typedef fpdf_pagelink_t__* FPDF_PAGELINK link_page);
    ///<summary>Fetch the URL information for a detected web link.</summary>
    ///<param name = "link_page">Handle returned by FPDFLink_LoadWebLinks.</param>
    ///<param name = "link_index">Zero-based index for the link.</param>
    ///<param name = "buffer">A unicode buffer for the result.</param>
    ///<param name = "buflen">
    /// Number of 16-bit code units (not bytes) for the
    /// buffer, including an additional terminator.
    ///</param>
    ///<returns>
    /// If |buffer| is NULL or |buflen| is zero, return the number of 16-bit
    /// code units (not bytes) needed to buffer the result (an additional
    /// terminator is included in this count).
    /// Otherwise, copy the result into |buffer|, truncating at |buflen| if
    /// the result is too large to fit, and return the number of 16-bit code
    /// units actually copied into the buffer (the additional terminator is
    /// also included in this count).
    /// If |link_index| does not correspond to a valid link, then the result
    /// is an empty string.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFLink_GetURL), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFLink_GetURL(typedef fpdf_pagelink_t__* FPDF_PAGELINK link_page, int link_index, unsigned short* buffer, int buflen);
    ///<summary>Count number of rectangular areas for the link.</summary>
    ///<param name = "link_page">Handle returned by FPDFLink_LoadWebLinks.</param>
    ///<param name = "link_index">Zero-based index for the link.</param>
    ///<returns>
    /// Number of rectangular areas for the link.  If |link_index| does
    /// not correspond to a valid link, then 0 is returned.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFLink_CountRects), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFLink_CountRects(typedef fpdf_pagelink_t__* FPDF_PAGELINK link_page, int link_index);
    ///<summary>Fetch the boundaries of a rectangle for a link.</summary>
    ///<param name = "link_page">Handle returned by FPDFLink_LoadWebLinks.</param>
    ///<param name = "link_index">Zero-based index for the link.</param>
    ///<param name = "rect_index">Zero-based index for a rectangle.</param>
    ///<param name = "left">
    /// Pointer to a double value receiving the rectangle
    /// left boundary.
    ///</param>
    ///<param name = "top">
    /// Pointer to a double value receiving the rectangle
    /// top boundary.
    ///</param>
    ///<param name = "right">
    /// Pointer to a double value receiving the rectangle
    /// right boundary.
    ///</param>
    ///<param name = "bottom">
    /// Pointer to a double value receiving the rectangle
    /// bottom boundary.
    ///</param>
    ///<returns>
    /// On success, return TRUE and fill in |left|, |top|, |right|, and
    /// |bottom|. If |link_page| is invalid or if |link_index| does not
    /// correspond to a valid link, then return FALSE, and the out
    /// parameters remain unmodified.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFLink_GetRect), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFLink_GetRect(typedef fpdf_pagelink_t__* FPDF_PAGELINK link_page, int link_index, int rect_index, double* left, double* top, double* right, double* bottom);
    ///<summary>Fetch the start char index and char count for a link.</summary>
    ///<param name = "link_page">Handle returned by FPDFLink_LoadWebLinks.</param>
    ///<param name = "link_index">Zero-based index for the link.</param>
    ///<param name = "start_char_index">pointer to int receiving the start char index</param>
    ///<param name = "char_count">pointer to int receiving the char count</param>
    ///<returns>
    /// On success, return TRUE and fill in |start_char_index| and
    /// |char_count|. if |link_page| is invalid or if |link_index| does
    /// not correspond to a valid link, then return FALSE and the out
    /// parameters remain unmodified.
    ///</returns>
    [DllImport(DllName, EntryPoint = nameof(FPDFLink_GetTextRange), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFLink_GetTextRange(typedef fpdf_pagelink_t__* FPDF_PAGELINK link_page, int link_index, int* start_char_index, int* char_count);
    ///<summary>Release resources used by weblink feature.</summary>
    ///<param name = "link_page">Handle returned by FPDFLink_LoadWebLinks.</param>
    [DllImport(DllName, EntryPoint = nameof(FPDFLink_CloseWebLinks), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFLink_CloseWebLinks(typedef fpdf_pagelink_t__* FPDF_PAGELINK link_page);
    [DllImport(DllName, EntryPoint = nameof(FPDFPage_SetMediaBox), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPage_SetMediaBox(typedef fpdf_page_t__* FPDF_PAGE page, float left, float bottom, float right, float top);
    [DllImport(DllName, EntryPoint = nameof(FPDFPage_SetCropBox), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPage_SetCropBox(typedef fpdf_page_t__* FPDF_PAGE page, float left, float bottom, float right, float top);
    [DllImport(DllName, EntryPoint = nameof(FPDFPage_SetBleedBox), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPage_SetBleedBox(typedef fpdf_page_t__* FPDF_PAGE page, float left, float bottom, float right, float top);
    [DllImport(DllName, EntryPoint = nameof(FPDFPage_SetTrimBox), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPage_SetTrimBox(typedef fpdf_page_t__* FPDF_PAGE page, float left, float bottom, float right, float top);
    [DllImport(DllName, EntryPoint = nameof(FPDFPage_SetArtBox), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPage_SetArtBox(typedef fpdf_page_t__* FPDF_PAGE page, float left, float bottom, float right, float top);
    [DllImport(DllName, EntryPoint = nameof(FPDFPage_GetMediaBox), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPage_GetMediaBox(typedef fpdf_page_t__* FPDF_PAGE page, float* left, float* bottom, float* right, float* top);
    [DllImport(DllName, EntryPoint = nameof(FPDFPage_GetCropBox), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPage_GetCropBox(typedef fpdf_page_t__* FPDF_PAGE page, float* left, float* bottom, float* right, float* top);
    [DllImport(DllName, EntryPoint = nameof(FPDFPage_GetBleedBox), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPage_GetBleedBox(typedef fpdf_page_t__* FPDF_PAGE page, float* left, float* bottom, float* right, float* top);
    [DllImport(DllName, EntryPoint = nameof(FPDFPage_GetTrimBox), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPage_GetTrimBox(typedef fpdf_page_t__* FPDF_PAGE page, float* left, float* bottom, float* right, float* top);
    [DllImport(DllName, EntryPoint = nameof(FPDFPage_GetArtBox), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPage_GetArtBox(typedef fpdf_page_t__* FPDF_PAGE page, float* left, float* bottom, float* right, float* top);
    [DllImport(DllName, EntryPoint = nameof(FPDFPage_TransFormWithClip), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPage_TransFormWithClip(typedef fpdf_page_t__* FPDF_PAGE page, const FS_MATRIX* matrix, const FS_RECTF* clipRect);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObj_TransformClipPath), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObj_TransformClipPath(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT page_object, double a, double b, double c, double d, double e, double f);
    [DllImport(DllName, EntryPoint = nameof(FPDFPageObj_GetClipPath), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPageObj_GetClipPath(typedef fpdf_pageobject_t__* FPDF_PAGEOBJECT page_object);
    [DllImport(DllName, EntryPoint = nameof(FPDFClipPath_CountPaths), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFClipPath_CountPaths(typedef fpdf_clippath_t__* FPDF_CLIPPATH clip_path);
    [DllImport(DllName, EntryPoint = nameof(FPDFClipPath_CountPathSegments), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFClipPath_CountPathSegments(typedef fpdf_clippath_t__* FPDF_CLIPPATH clip_path, int path_index);
    [DllImport(DllName, EntryPoint = nameof(FPDFClipPath_GetPathSegment), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFClipPath_GetPathSegment(typedef fpdf_clippath_t__* FPDF_CLIPPATH clip_path, int path_index, int segment_index);
    [DllImport(DllName, EntryPoint = nameof(FPDF_CreateClipPath), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_CreateClipPath(float left, float bottom, float right, float top);
    [DllImport(DllName, EntryPoint = nameof(FPDF_DestroyClipPath), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDF_DestroyClipPath(typedef fpdf_clippath_t__* FPDF_CLIPPATH clipPath);
    [DllImport(DllName, EntryPoint = nameof(FPDFPage_InsertClipPath), SetLastError = true), SuppressUnmanagedCodeSecurity]
    internal static extern bool FPDFPage_InsertClipPath(typedef fpdf_page_t__* FPDF_PAGE page, typedef fpdf_clippath_t__* FPDF_CLIPPATH clipPath);
}